'''
DESCRIPTION
This is a Library of useful Everyday Rigging Tools.
This project originally was to make a modular monster auto rigger. However in the course of my riogging time
I have determined while an exact limb type auto rig is nice, having each of the systems and tools modular adds more
fuctionality tot he library then just a standard autorig.

Usage Instructions
----------
Upon running this script A menu titled Ck Extra Rigging Tools Will appear. All toools can be launched off of that.
I have tried to group them into logical groups for ease of finding and annotated them for Hover descriptions.

Currently At Version 1.0
'''





####################################################################################################################################################################################################################################################################################################
#    Import Commands #
####################################################################################################################################################################################################################################################################################################
import maya.cmds as cmds
import math
import maya.OpenMaya as om
from functools import partial
import random as rand
from maya import cmds , OpenMaya
import pymel.core as pm


####################################################################################################################################################################################################################################################################################################
#              Classes
####################################################################################################################################################################################################################################################################################################


####################################################################################################################################################################################################################################################################################################

class rigCntsUI(object):
    '''
    This Class will spawn Rigging Contol Shapes on the selected Object or on the origin. It can be expanded with more
    shapes by updating the 3 dictionaries with more options. "riggingShapes" is the point location for each EP on drawn shape,
    "modes" sets the curve mode to linier or cubic. "buttonNames" sets the name to show in the UI.

    Usage Instructions
    ----------
    Upon Running the Script a visable ui will appear prompting for the shape to be created


    Methods
    ----------
    createwin() : Launches UI
    run() : Draws Shape selected in ui from the library of shapes

    Returns
    -------
    run() returns name of Shape created.
    other methods return NONE


    '''
    def __init__(self):
        self.riggingShapes = {
            "Pole_ctrl": [(1.311341578e-07, -1.0, -1.0), (0.0, 1.0, 0.0), (-1.0, -1.0, -8.742277657e-08),
                          (-4.3711388290000005e-08, -1.0, 1.0), (0.0, 1.0, 0.0), (1.0, -1.0, 0.0),
                          (1.311341578e-07, -1.0, -1.0), (-4.3711388290000005e-08, -1.0, 1.0), (1.0, -1.0, 0.0),
                          (-1.0, -1.0, -8.742277657e-08), (1.311341578e-07, -1.0, -1.0)],
            "RotX_Half_ctrl": [(0.0, 4.0, 1.567223571e-08), (0.0, 3.750151511164026, 1.0555833218215913),
                               (0.0, 3.250454532812127, 3.166749939187479),
                               (0.0, -0.03125540357773617, 4.303563001323913),
                               (0.0, -3.1254329234706595, 3.618998057309055),
                               (0.0, -4.0001948852786935, 0.0003371077286400156),
                               (0.0, -4.000000000068596, -1.0547118730169778e-15),
                               (0.0, -4.000024110480982, 4.235163872522594e-05),
                               (0.0, -4.518137311117764, 3.862367748237456e-08),
                               (0.0, -4.518123666947561, -2.2363607260053625e-13),
                               (0.0, -4.51813901812503, 2.946276744233565e-07),
                               (0.0, -3.959190358513086, -0.5589430729112267),
                               (0.0, -3.959180813974836, -0.5589428529000597),
                               (0.0, -3.9591867789434048, -0.5589426047976878),
                               (0.0, -3.518134263204603, -1.0000018725824462),
                               (0.0, -3.518123666964727, -0.9999999999945024),
                               (0.0, -3.518133973698509, -1.000001792471605),
                               (0.0, -2.965199693096602, -0.4470705257517693),
                               (0.0, -2.965192229979975, -0.4470685629942691),
                               (0.0, -2.965197086570584, -0.44707012036815286),
                               (0.0, -2.518131275570747, -9.13343854658244e-07),
                               (0.0, -2.5181236669750424, 3.603200062240848e-12),
                               (0.0, -2.518127736431621, -6.381649021725001e-07),
                               (0.0, -3.000006293702115, -1.4651797575762068e-05),
                               (0.0, -2.999999998812318, -1.4424255887289052e-27),
                               (0.0, -3.000012415361161, -9.427973330598352e-05),
                               (0.0, -2.3500211547939918, 2.742681551896641),
                               (0.0, -0.0028296106591095063, 3.1286771568203178),
                               (0.0, 2.361339597561211, 2.7426098208435326),
                               (0.0, 2.9773755218818447, 7.309226885575001e-05),
                               (0.0, 3.000000027213659, 1.5962130056264356e-15),
                               (0.0, 2.9866692322645627, 2.3672781616462498e-05),
                               (0.0, 3.4933348694756994, 1.1844221011811847e-05), (0.0, 4.0, 1.567223571e-08)],
            "RotX_ctrl": [(-8.881784196999999e-16, -2.9573265409999996, -1.3322676299999999e-15),
                          (-8.881784135528909e-16, -2.7698993129920053, 0.7835623605608272),
                          (-8.88178401258692e-16, -2.395044857007747, 2.3506870815499794),
                          (-7.405951732972906e-23, 0.06562465838243205, 3.3251737371234587),
                          (8.881786974310398e-16, 2.3885869747694692, 2.348617969770535),
                          (8.881773834213285e-16, 3.3639902564318516, 0.008276446266489764),
                          (3.867912289634498e-21, 2.4114927551621936, -2.381723754814667),
                          (-1.4435231786665854e-20, -0.025998464253667912, -3.2093034896488524),
                          (-8.907486660453389e-16, -1.585794541110744, -2.879517143432281),
                          (-8.881893702552072e-16, -2.5171165655214502, -1.5598023575181588),
                          (-8.881784196702718e-16, -2.517095074915924, -1.559768532947966),
                          (-8.881900723131344e-16, -2.5171175915955515, -1.5598044162081923),
                          (-8.881642887781197e-16, -3.239556391857727, -2.2822806392775297),
                          (-8.881784196985751e-16, -3.2396041369971766, -2.2822775949981136),
                          (-8.881645576458601e-16, -3.2395575053332886, -2.282278986142108),
                          (-8.90271599303933e-16, -2.0214949991915923, -3.8593696532969344),
                          (4.101294183688306e-21, -0.06357622419305733, -4.277730705930055),
                          (-8.960332740628934e-22, 3.205590164339502, -3.173671899991538),
                          (8.881779027785757e-16, 4.4678190666065145, 0.0018555575321333863),
                          (8.881813837431283e-16, 3.1791743240732915, 3.166249669979654),
                          (-1.1338840529835656e-20, 0.04208713687986117, 4.303708511092505),
                          (-8.881360284892532e-16, -3.0914821201680014, 3.618916285538278),
                          (-8.882697734469052e-16, -3.957614616727014, 0.00043090151016340157),
                          (-8.881784196325987e-16, -3.957326540789418, -4.930020209871074e-10),
                          (-8.881898905730285e-16, -3.9573623529400797, 5.4128887679335894e-05),
                          (-8.881813481636958e-16, -4.475463712355853, 3.862367722476817e-08),
                          (-8.881784196885134e-16, -4.475450208948115, -2.2408016114864182e-13),
                          (-8.881817345859141e-16, -4.4754654004329275, 2.9492994480569214e-07),
                          (-8.881803394205287e-16, -3.9165168093129465, -0.5589430730130904),
                          (-8.881784196950642e-16, -3.91650735597507, -0.5589428529000592),
                          (-8.881795435950275e-16, -3.916513267380635, -0.558942604855897),
                          (-8.881808521133753e-16, -3.4754606875022875, -1.0000018723423396),
                          (-8.881784196920745e-16, -3.4754502089651096, -0.999999999994503),
                          (-8.881806822853313e-16, -3.475460406775195, -1.0000017923551896),
                          (-8.8818036961497e-16, -2.9225261712740425, -0.4470705259554961),
                          (-8.881784196949335e-16, -2.922518771980148, -0.4470685629942685),
                          (-8.881796080211744e-16, -2.9225236459186954, -0.4470701205573278),
                          (-8.591778474272568e-16, -2.389410915165901, -8.99407745006725e-07),
                          (-8.881785453433429e-16, -2.475450581760279, 3.5423799689602132e-12),
                          (-8.583861207171445e-16, -2.3870617564487757, -6.238486628980994e-07),
                          (-8.732822856686176e-16, -2.672194444596685, -3.1192400844353894e-07),
                          (-8.881784196999999e-16, -2.9573265409999996, -1.3322676299999999e-15)],
            "RotY_Half_ctrl": [(4.0, -9.596476685000002e-25, 1.567223571e-08),
                               (3.7501501259167624, -6.463600391841969e-17, 1.055586051321985),
                               (3.2504503770540247, -1.9390801014166075e-16, 3.166758127688681),
                               (-0.031238780647192918, -2.635152271277253e-16, 4.303530247318921),
                               (-3.1254952589763456, -2.2160724025717393e-16, 3.619120884827756),
                               (-4.000060517884042, -4.429922529892483e-21, 7.234612503312112e-05),
                               (-3.999999999771171, 6.16297582164095e-32, -1.0547118729385534e-15),
                               (-4.000007238697245, -5.57627924552967e-22, 9.106755064517211e-06),
                               (-4.518137309924507, 1.5363990498572401e-37, 3.8623677523140567e-08),
                               (-4.518123666947569, -7.396320725028412e-43, -2.2363607280071396e-13),
                               (-4.518139015796724, 2.1488495547466427e-37, 2.9462767446498987e-07),
                               (-3.959190358513086, 3.184510444684601e-43, -0.5589430729112267),
                               (-3.959180813974836, 0.0, -0.5589428529000597),
                               (-3.9591867789434048, 2.3487653640063646e-43, -0.5589426047976878),
                               (-3.518134263204603, 0.0, -1.0000018725824462),
                               (-3.518123666964727, 0.0, -0.9999999999945024),
                               (-3.518133973698509, 0.0, -1.000001792471605),
                               (-2.9651996930966016, 0.0, -0.4470705257517693),
                               (-2.965192229979975, 0.0, -0.4470685629942691),
                               (-2.9651970865705843, 0.0, -0.44707012036815286),
                               (-2.518131275457944, -3.168277651141891e-44, -9.133438546027328e-07),
                               (-2.518123666975043, 0.0, 3.6032000620290897e-12),
                               (-2.5181277363239443, -7.66380158872371e-44, -6.381649021447444e-07),
                               (-3.000020823729901, 9.763423674050992e-22, -1.5944882436728945e-05),
                               (-2.9999999988575694, -3.9681736093822516e-43, 6.655431171554618e-27),
                               (-3.000105732668199, 6.281475593485224e-21, -0.00010258428827049944),
                               (-2.349975488664765, -1.6794106241761423e-16, 2.7426856898374425),
                               (-0.0028494667042840843, -1.9157609933988973e-16, 3.1286751308559),
                               (2.3613733556272343, -1.6793665962414013e-16, 2.7426137867604026),
                               (2.977309991414093, -3.991681320812827e-21, 6.518910318947133e-05),
                               (3.0000000272001657, -9.532791380820475e-32, 1.5962130775732814e-15),
                               (2.986645210428565, -1.2931944719931613e-21, 2.1119468490417215e-05),
                               (3.4933228585577005, -6.470767367722858e-22, 1.0567565087117177e-05)],
            "RotY_ctrl": [(-2.9573265409999996, 7.395570985999999e-32, -1.3322676299999999e-15),
                          (-2.7698993129920053, -4.797935680209866e-17, 0.7835623605608272),
                          (-2.395044857007747, -1.4393807039818157e-16, 2.3506870815499794),
                          (0.06562465838243205, -2.0360816876583708e-16, 3.3251737371234587),
                          (2.3885869747694692, -1.438113739271263e-16, 2.348617969770535),
                          (3.3639902564318516, -5.067858321309804e-19, 0.008276446266489764),
                          (2.4114927551621936, 1.4583851725431232e-16, -2.381723754814667),
                          (-0.025998464253667912, 1.965131671279751e-16, -3.2093034896488524),
                          (-1.585794541110744, 1.7631956007982538e-16, -2.879517143432281),
                          (-2.5171165655214502, 9.551035616979768e-17, -1.5598023575181588),
                          (-2.517095074915924, 9.550827706678038e-17, -1.559768532947966),
                          (-2.5171175915955515, 9.551053126309228e-17, -1.5598044162081923),
                          (-3.239556391857727, 2.1006850158487017e-22, -2.2822806392775297),
                          (-3.2396041369971766, -2.9470386120624077e-28, -2.2822775949981136),
                          (-3.2395575053332886, 1.1785185288762472e-22, -2.282278986142108),
                          (-2.0214949991915923, 5.297688592882887e-16, -3.8593696532969344),
                          (-0.06357622419305733, 1.4551309441371528e-16, -4.277730705930055),
                          (3.205590164339502, 2.25526690914299e-16, -3.173671899991538),
                          (4.4678190666065145, -8.472590926099158e-18, 0.0018555575321333863),
                          (3.1791743240732915, -1.916363272149869e-16, 3.166249669979654),
                          (0.04208713687986117, -2.641293673256309e-16, 4.303708511092505),
                          (-3.0914821201680014, -2.2142236227511333e-16, 3.618916285538278),
                          (-3.957614616727014, -2.6385083118583967e-20, 0.00043090151016340157),
                          (-3.957326540789418, 3.018764000950376e-26, -4.930020209871074e-10),
                          (-3.9573623529400797, -3.3144342839020844e-21, 5.4128887679335894e-05),
                          (-4.475463712355853, 2.465213821210679e-32, 3.862367722476817e-08),
                          (-4.475450208948115, 2.465190328894156e-32, -2.2408016114864182e-13),
                          (-4.4754654004329275, -1.8508739661674988e-26, 2.9492994480569214e-07),
                          (-3.9165168093129465, 2.465195657253637e-32, -0.5589430730130904),
                          (-3.91650735597507, 2.4651903289863006e-32, -0.5589428529000592),
                          (-3.916513267380635, 2.4651934484658953e-32, -0.558942604855897),
                          (-3.4754606875022875, 2.465197080369764e-32, -1.0000018723423396),
                          (-3.4754502089651096, 2.4651903289780023e-32, -0.999999999994503),
                          (-3.475460406775195, 2.465196608894632e-32, -1.0000017923551896),
                          (-2.9225261712740425, 2.46519575848346e-32, -0.4470705259554961),
                          (-2.922518771980148, 2.465190328985939e-32, -0.4470685629942685),
                          (-2.9225236459186954, 2.4651936718335367e-32, -0.4470701205573278),
                          (-2.389410915165901, 2.3313658857246274e-32, -8.99407745006725e-07),
                          (-2.475450581760279, 2.465190908782145e-32, 3.5423799689602132e-12),
                          (-2.3870617564487757, 2.3277129083525808e-32, -6.238486628980994e-07),
                          (-2.672194444596685, 4.8616445763795236e-32, -3.1192400844353894e-07),
                          (-2.9573265409999996, 7.395570985999999e-32, -1.3322676299999999e-15)],
            "RotZ_Half_ctrl": [(4.0, -1.567223571e-08, 2.5202877190000002e-24),
                               (3.750151511164026, -1.0555833218215913, 1.697507447996472e-16),
                               (3.250454532812127, -3.166749939187479, 5.092522301778091e-16),
                               (-0.03125540357773617, -4.303563001323913, 6.920657137871346e-16),
                               (-3.1254329234706595, -3.618998057309055, 5.819792743618588e-16),
                               (-4.0001948852786935, -0.0003371077286400156, 5.42110573704337e-20),
                               (-4.000000000068596, 1.0547118730169778e-15, -1.7256332300277778e-31),
                               (-4.000024110480982, -4.235163872522594e-05, 6.81066294558283e-21),
                               (-4.518137311117764, -3.862367748237456e-08, 8.576179204147901e-24),
                               (-4.518123666947561, 2.2363607260053625e-13, -4.965718336736788e-29),
                               (-4.51813901812503, -2.946276744233565e-07, 6.542048554035193e-23),
                               (-3.959190358513086, 0.5589430729112267, -1.241102937500731e-16),
                               (-3.959180813974836, 0.5589428529000597, -1.2411024490001325e-16),
                               (-3.9591867789434048, 0.5589426047976878, -1.2411018981283405e-16),
                               (-3.518134263204603, 1.0000018725824462, -2.2204502069924255e-16),
                               (-3.518123666964727, 0.9999999999945024, -2.2204460489877925e-16),
                               (-3.518133973698509, 1.000001792471605, -2.2204500290783127e-16),
                               (-2.965199693096602, 0.4470705257517693, -9.926959826902441e-17),
                               (-2.965192229979975, 0.4470685629942691, -9.926916244872753e-17),
                               (-2.965197086570584, 0.44707012036815286, -9.926950825739504e-17),
                               (-2.518131275570747, 9.13343854658244e-07, -2.0280307537445797e-22),
                               (-2.5181236669750424, -3.603200062240848e-12, 8.000711343096272e-28),
                               (-2.518127736431621, 6.381649021725001e-07, -1.41701073586077e-22),
                               (-3.000006293702115, 1.4651797575762068e-05, -2.3561888484311982e-21),
                               (-2.999999998812318, 1.4424255887289052e-27, -2.3428095171692228e-43),
                               (-3.000012415361161, 9.427973330598352e-05, -1.5161337872903107e-20),
                               (-2.3500211547939918, -2.742681551896641, 4.410568323659692e-16),
                               (-0.0028296106591095063, -3.1286771568203178, 5.031296599762017e-16),
                               (2.361339597561211, -2.7426098208435326, 4.410452971326719e-16),
                               (2.9773755218818447, -7.309226885575001e-05, 1.1754133302930139e-20),
                               (3.000000027213659, -1.5962130056264356e-15, 2.591025768979394e-31),
                               (2.9866692322645627, -2.3672781616462498e-05, 3.806873628733419e-21),
                               (3.4933348694756994, -1.1844221011811847e-05, 1.9046960071383487e-21),
                               (4.0, -1.567223571e-08, 2.5202877190000002e-24)],
            "RotZ_ctrl": [(-2.9573265409999996, 1.3322676299999999e-15, -2.4651903289999996e-31),
                          (-2.7698993129920053, -0.7835623605608272, 1.2600643792041127e-16),
                          (-2.395044857007747, -2.3506870815499794, 3.780193137399353e-16),
                          (0.06562465838243205, -3.3251737371234587, 5.347287201314729e-16),
                          (2.3885869747694692, -2.348617969770535, 3.776865751043816e-16),
                          (3.3639902564318516, -0.008276446266489764, 1.3309544054074831e-18),
                          (2.4114927551621936, 2.381723754814667, -3.830103927234367e-16),
                          (-0.025998464253667912, 3.2093034896488524, -5.160953584872847e-16),
                          (-1.585794541110744, 2.879517143432281, -4.630616861693434e-16),
                          (-2.5171165655214502, 1.5598023575181588, -2.5083534205756854e-16),
                          (-2.517095074915924, 1.559768532947966, -2.508299105916659e-16),
                          (-2.5171175915955515, 1.5598044162081923, -2.5083562407478774e-16),
                          (-3.239556391857727, 2.2822806392775297, -5.067678928593088e-16),
                          (-3.2396041369971766, 2.2822775949981136, -5.067674269998758e-16),
                          (-3.2395575053332886, 2.282278986142108, -5.067676180535023e-16),
                          (-2.0214949991915923, 3.8593696532969344, -3.271833500977718e-16),
                          (-0.06357622419305733, 4.277730705930055, -8.043339304625338e-16),
                          (3.205590164339502, 3.173671899991538, -4.791700320152695e-16),
                          (4.4678190666065145, -0.0018555575321333863, -8.060574399024677e-18),
                          (3.1791743240732915, -3.166249669979654, 5.114123296277419e-16),
                          (0.04208713687986117, -4.303708511092505, 6.914858888516045e-16),
                          (-3.0914821201680014, -3.618916285538278, 5.821384743472769e-16),
                          (-3.957614616727014, -0.00043090151016340157, 6.929427243043473e-20),
                          (-3.957326540789418, 4.930020209871074e-10, -7.928084824899401e-26),
                          (-3.9573623529400797, -5.4128887679335894e-05, 8.704593191219866e-21),
                          (-4.475463712355853, -3.862367722476817e-08, 8.576179146658902e-24),
                          (-4.475450208948115, 2.2408016114864182e-13, -4.9755790833583714e-29),
                          (-4.4754654004329275, -2.9492994480569214e-07, 6.546909428497438e-23),
                          (-3.9165168093129465, 0.5589430730130904, -1.24110293774307e-16),
                          (-3.91650735597507, 0.5589428529000592, -1.2411024490001315e-16),
                          (-3.916513267380635, 0.558942604855897, -1.2411018981929674e-16),
                          (-3.4754606875022875, 1.0000018723423396, -2.2204502064592817e-16),
                          (-3.4754502089651096, 0.999999999994503, -2.2204460489877937e-16),
                          (-3.475460406775195, 1.0000017923551896, -2.220450028819819e-16),
                          (-2.9225261712740425, 0.4470705259554961, -9.926959831426085e-17),
                          (-2.922518771980148, 0.4470685629942685, -9.926916244872738e-17),
                          (-2.9225236459186954, 0.4470701205573278, -9.926950829293797e-17),
                          (-2.389410915165901, 8.99407745006725e-07, -1.9970863740090187e-22),
                          (-2.475450581760279, -3.5423799689602132e-12, 7.865663607514591e-28),
                          (-2.3870617564487757, 6.238486628980994e-07, -1.3852222988676536e-22),
                          (-2.672194444596685, 3.1192400844353894e-07, -6.926104320018122e-23),
                          (-2.9573265409999996, 1.3322676299999999e-15, -2.4651903289999996e-31)],
            "DPad_ctrl": [(-3.86937328, 0.0, 1.0), (-1.0, 0.0, 1.0), (-1.0, 0.0, 1.0), (-1.0, 0.0, 1.0),
                          (-1.0, 0.0, 3.86937328), (-1.0, 0.0, 3.86937328), (-1.0, 0.0, 3.86937328),
                          (-3.774758284e-15, -2.4492935980000003e-16, 4.0),
                          (0.9999999993, -2.3693077960000004e-16, 3.869373271),
                          (0.9999999993, -2.3693077960000004e-16, 3.869373271),
                          (0.9999999993, -2.3693077960000004e-16, 3.869373271), (1.0, 0.0, 1.0), (1.0, 0.0, 1.0),
                          (1.0, 0.0, 1.0), (3.86937328, 0.0, 1.0), (3.86937328, 0.0, 1.0), (3.86937328, 0.0, 1.0),
                          (4.0, -3.5128962190000006e-31, 5.828670879e-15),
                          (3.869373271, 6.123233991e-17, -0.9999999993), (3.869373271, 6.123233991e-17, -0.9999999993),
                          (3.869373271, 6.123233991e-17, -0.9999999993), (1.0, 0.0, -1.0), (1.0, 0.0, -1.0),
                          (1.0, 0.0, -1.0), (1.0, 0.0, -3.869373272), (1.0, 0.0, -3.869373272),
                          (1.0, 0.0, -3.869373272), (-3.219646771e-15, 2.4492935980000003e-16, -4.0),
                          (-0.9999999999, 2.3693077960000004e-16, -3.869373271),
                          (-0.9999999999, 2.3693077960000004e-16, -3.869373271),
                          (-0.9999999999, 2.3693077960000004e-16, -3.869373271), (-1.0, 0.0, -1.0), (-1.0, 0.0, -1.0),
                          (-1.0, 0.0, -1.0), (-3.86937328, 0.0, -1.0), (-3.86937328, 0.0, -1.0),
                          (-3.86937328, 0.0, -1.0), (-4.0, 5.854827031e-32, -8.881784197e-16), (-3.86937328, 0.0, 1.0)],
            "TransRot_ctrl": [(-3.869373271014554, -6.123233991344783e-17, 0.9999999993563073),
                              (-3.684593549603059, -1.0011231145212997e-16, 1.6349582193188845),
                              (-3.3150341068058222, -1.7787225454240176e-16, 2.9048746590625987),
                              (-0.9990461865389836, -2.369080382546631e-16, 3.8690011918991742),
                              (-1.0000000002211442, -2.369307796219551e-16, 3.8693732713595326),
                              (-0.9996197825356085, -2.369217853566712e-16, 3.8692245410928985),
                              (-1.0000014168862006, -2.706806617055778e-22, 5.000006264173077),
                              (-0.9999999999975336, 5.97149632873018e-28, 4.999999999989268),
                              (-1.000000575059492, -2.1947802789410872e-22, 5.000003911357925),
                              (-2.0000021374743397, -2.571049669591816e-28, 5.0000085212614955),
                              (-1.9999999999962408, 0.0, 4.999999999982704),
                              (-2.0000051003880746, -8.664663064968752e-28, 5.000022501987769),
                              (-7.627136425419379e-07, 0.0, 8.000002772468825),
                              (5.341186857021829e-13, 0.0, 7.9999999999985585),
                              (-8.879684054719652e-07, 0.0, 8.000002162138365),
                              (2.000000529346348, 0.0, 5.000003437657415), (1.9999999999997138, 0.0, 4.999999999997925),
                              (2.0000004288579585, 0.0, 5.0000007590638464),
                              (1.0000029993062247, 8.507669474312283e-29, 5.000008612021208),
                              (0.9999999999933082, 0.0, 4.999999999982427),
                              (1.0000027711712807, 3.0534289076501245e-28, 5.00000757850466),
                              (0.999930200024871, 6.708788028420534e-21, 3.8693005195822634),
                              (1.0000000001700522, -1.625392592703183e-26, 3.8693732801802083),
                              (0.999823065746452, 1.6849566107198177e-20, 3.8691832025947615),
                              (3.222221288139529, -3.1577403220648583e-16, 3.2222524870726805),
                              (3.8694424777079663, -6.123349429085327e-17, 1.0000199535924106),
                              (3.869373270934786, -6.123233990895688e-17, 0.9999999992820939),
                              (3.869400489591348, -6.123282671732484e-17, 1.0000080190795464),
                              (5.000006266093928, -6.995400123684274e-23, 1.000001417410069),
                              (4.999999999989261, 1.543256005862955e-28, 0.9999999999975324),
                              (5.000003913686228, -5.672125606838019e-23, 1.0000005755833599),
                              (5.000008521901779, -6.644545396985933e-29, 2.0000021376489627),
                              (4.999999999982701, 0.0, 1.9999999999962403),
                              (5.000022498262476, -2.239270105985363e-28, 2.0000051003880746),
                              (8.000002780850728, 0.0, 7.627136432982772e-07),
                              (7.999999999998553, 0.0, -5.341186871414772e-13),
                              (8.000002169588944, 0.0, 8.879684062768768e-07),
                              (5.000003431370985, 0.0, -2.00000052678521), (4.99999999999793, 0.0, -1.999999999999715),
                              (5.00000075836535, 0.0, -2.000000428508712),
                              (5.000008613949448, 1.5944523534070158e-28, -1.0000029996502744),
                              (4.999999999982425, 0.0, -0.9999999999933072),
                              (5.000007580393806, 5.720020199378223e-28, -1.0000027715540984),
                              (3.8693632037074424, -1.2779516750728346e-21, -0.9999777618362053),
                              (3.8693732720261074, 2.9609361982899812e-27, -1.0000000000526097),
                              (3.8693404401489317, -3.221794504546199e-21, -0.9999423590442925),
                              (3.2222126884385567, 2.279196241450239e-16, -3.2222194823987853),
                              (0.9999423092329972, 2.3692876625051563e-16, -3.86932680129235),
                              (0.9999999993570916, 2.3693077960202337e-16, -3.869373271046519),
                              (0.9999770623842771, 2.3693005097186685e-16, -3.869354370271872),
                              (1.0000014167988895, 2.706764625250236e-22, -5.000006263940247),
                              (0.9999999999975335, -5.971391640143691e-28, -4.999999999989267),
                              (1.0000005751177017, 2.194741677142026e-22, -5.0000039115907615),
                              (2.000002137241509, 2.5710045959662305e-28, -5.00000852038838),
                              (1.9999999999962417, 0.0, -4.999999999982703),
                              (2.0000050999224133, 8.664511057562467e-28, -5.000022499193801),
                              (7.627136407222128e-07, 0.0, -8.000002781316388),
                              (-5.341186834820302e-13, 0.0, -7.999999999998555),
                              (8.879684037788752e-07, 0.0, -8.000002169588946),
                              (-2.0000005308597477, 0.0, -5.000003440451385),
                              (-1.9999999999997127, 0.0, -4.9999999999979226),
                              (-2.000000429207205, 0.0, -5.000000759995172),
                              (-1.0000029998723752, -8.508577066447587e-29, -5.000008614751654),
                              (-0.9999999999933069, 0.0, -4.999999999982423),
                              (-1.0000027716320097, -3.0537546298466724e-28, -5.000007580813892),
                              (-0.9999407431169122, -6.709107417641371e-21, -3.8693413082158634),
                              (-1.0000000001445095, 1.6254699563686535e-26, -3.8693732710813697),
                              (-0.9998495098192551, -1.6850367651310425e-20, -3.869285520900744),
                              (-3.2223255534897794, 3.1578279093280205e-16, -3.222318765983384),
                              (-3.869207509786371, 6.121597777203017e-17, -0.9997850708940692),
                              (-3.8693732711602276, 6.123233992578341e-17, -0.9999999995074526),
                              (-3.8693068080827984, 6.122584289603654e-17, -0.9999143716253577),
                              (-5.000006263940247, 6.995421732310101e-23, -1.0000014168570972),
                              (-4.999999999989267, -1.5432613876287413e-28, -0.9999999999975335),
                              (-5.0000039115907615, 5.67214547349873e-23, -1.0000005751759093),
                              (-5.00000852038838, 6.644568568330576e-29, -2.000002137241509),
                              (-4.999999999982703, 0.0, -1.9999999999962417),
                              (-5.000022499193801, 2.2392779205542577e-28, -2.0000050999224133),
                              (-8.000002781316388, 0.0, -7.627136406372679e-07),
                              (-7.999999999998555, 0.0, 5.341186833926946e-13),
                              (-8.000002169588944, 0.0, -8.879684035883454e-07),
                              (-5.000003435121494, 9.431386444608143e-26, 2.000000528956529),
                              (-4.99999999999792, 0.0, 1.9999999999997118),
                              (-5.000000756738053, 8.30229086189656e-26, 2.000000428249179),
                              (-5.0061659011415145, -1.5694712635165523e-19, 1.0018140620706293),
                              (-4.99999998311682, 4.2989815729644675e-25, 0.9999999950325711),
                              (-5.009390453917813, -2.391618546136168e-19, 1.0027626305313624),
                              (-4.43938161014972, -3.073576436888672e-17, 1.0013813143283803),
                              (-3.869373271014554, -6.123233991344783e-17, 0.9999999993563073)],
            "Trans_ctrl": [(-1.0, 0.0, -1.0), (-1.0, 0.0, -5.0), (-2.0, 0.0, -5.0), (0.0, 0.0, -8.0), (2.0, 0.0, -5.0),
                           (1.0, 0.0, -5.0), (1.0, 0.0, -1.0), (5.0, 0.0, -1.0), (5.0, 0.0, -2.0), (8.0, 0.0, 0.0),
                           (5.0, 0.0, 2.0), (5.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 0.0, 5.0), (2.0, 0.0, 5.0),
                           (0.0, 0.0, 8.0), (-2.0, 0.0, 5.0), (-1.0, 0.0, 5.0), (-1.0, 0.0, 1.0), (-5.0, 0.0, 1.0),
                           (-5.0, 0.0, 2.0), (-8.0, 0.0, 0.0), (-5.0, 0.0, -2.0), (-5.0, 0.0, -1.0), (-1.0, 0.0, -1.0)],
        }

        self.modes = {
            "Pole_ctrl": 1,
            "RotX_Half_ctrl": 3,
            "RotX_ctrl": 3,
            "RotY_Half_ctrl": 3,
            "RotY_ctrl": 3,
            "RotZ_Half_ctrl": 3,
            "RotZ_ctrl": 3,
            "DPad_ctrl": 3,
            "TransRot_ctrl": 3,
            "Trans_ctrl": 1,
        }

        self.buttonNames = {
            "Pole_ctrl": "Pole\nPyramid",
            "RotX_Half_ctrl": "Half\nRotate\nX",
            "RotX_ctrl": "Rotate\nX",
            "RotY_Half_ctrl": "Half\nRotate\nY",
            "RotY_ctrl": "Rotate\nY",
            "RotZ_Half_ctrl": "Half\nRotate\nZ",
            "RotZ_ctrl": "Rotate\nZ",
            "DPad_ctrl": "Directional\nPad",
            "TransRot_ctrl": "Translate\nRotate",
            "Trans_ctrl": "Translate",
        }

    def createWin(self):
        if cmds.window('rigCntsUI', exists=True):
            cmds.deleteUI('rigCntsUI')
        self.rigWin = cmds.window('rigCntsUI', title='Spawn Rigging Controls')
        self.rigWinlayout = cmds.columnLayout()
        self.Titles = cmds.text('Select Object and click button to spawn control')
        self.ctrlgrid = cmds.gridLayout("cnts_Grid", numberOfRowsColumns=(1, 4), cellWidthHeight=(70, 50))
        orderbuttons = self.buttonNames.keys()
        orderbuttons.sort()
        for item in orderbuttons:
            print item
            btncmd = partial(self.run, item)
            cmds.button(item, l=self.buttonNames[item], p=self.ctrlgrid, c=btncmd)
        cmds.showWindow(self.rigWin)

    def run(self, key, *args):
        selected = cmds.ls(sl=True)
        newshape = self.drawShape(key)
        if len(selected) != 0:
            location = cmds.createNode('transform', n='Loc_' + selected[0])
            bind = cmds.parentConstraint(selected[0], location)
            cmds.delete(bind)
            cmds.parent(newshape, location)
            cmds.makeIdentity()
        print key

    def drawShape(self, key):
        print self.modes[key]
        print self.riggingShapes[key]
        shape = cmds.curve(n=key, d=self.modes[key], p=self.riggingShapes[key])
        return shape

####################################################################################################################################################################################################################################################################################################

class ribbon(object):
    '''
    This class creates a ribbon between two selected objects or at the origin.

    Usage Instructions
    ----------
    Assign this class to a variable:
    x = ribbon(binditems=[], size=10, joints=5, name=" ")
    Alternativly a UI has been included you can launch by running ribbonUI()

    Parameters
    ----------
    binditems : LIST
    size : INT
    joints : INT
    name : STRING

    Returns
    -------
    NONE
    '''
    # initialization of the object, determines if a selection was made or to create a default plane.
    def __init__(self, binditems=[], size=10, joints=5, name="TestPlane"):
        self.size = size
        self.joints = joints
        count = 0
        newname = name
        while cmds.objExists(newname + "_grp"):
            count += 1
            newname = name + str(count)
        self.name = newname
        self.selection = binditems
        self.itemLocators = []
        self.folliclesTX = []
        self.follicles = []
        self.jointList = []
        self.worldControl = cmds.spaceLocator(p=(0, 0, 0), name=self.name + ".world_loc")
        cmds.select(cl=True)

        # check to see if at least two items were selected, if so make locators at thir locations, if not create default length spaced locators.
        if len(self.selection) <= 1:
            cmds.select(cl=True)
            self.defaultLocators = [cmds.spaceLocator(p=(-self.size / 2, 0, 0), n=(self.name + "_location1_loc")),
                                    cmds.spaceLocator(p=(self.size / 2, 0, 0), n=(self.name + "_location2_loc"))]
            cmds.xform(self.defaultLocators[0], cp=True)
            cmds.xform(self.defaultLocators[1], cp=True)
            self.itemLocators.extend(self.defaultLocators)
            self.location1 = (-self.size / 2, 0, 0)
            self.location2 = (self.size / 2, 0, 0)
        else:
            for item in self.selection:
                itemlocator = cmds.spaceLocator(name=item + "_loc")
                constraint = cmds.parentConstraint(item, itemlocator)
                self.itemLocators.append(itemlocator)
                cmds.delete(constraint)
            self.location1 = cmds.getAttr(self.itemLocators[1][0] + ".t")[0]
            self.location2 = cmds.getAttr(self.itemLocators[0][0] + ".t")[0]
        self.defLine = cmds.curve(d=1, p=[self.location1, self.location2], name=self.name + "_connection_crv")
        # Find distance between locators
        self.distance = cmds.arclen(self.defLine)
        self.makeShader()
        self.makePlane()
        self.centerPlane()
        self.bindPlane()
        self.lockHideAll(self.baseplane[0])
        cmds.select(self.globalMoveCtr)

    def makePlane(self):
        # create Plane
        self.baseplane = cmds.nurbsPlane(width=self.distance, lr=1 / self.distance, u=self.joints, v=1, ax=[0, 1, 0],
                                         name=self.name + "_basePlane_nrb")
        cmds.hyperShade(assign=self.planeShader)

        # print self.baseplane
        cmds.delete(self.baseplane, ch=True)
        cmds.setAttr(cmds.listRelatives(self.baseplane[0], s=True)[0] + ".primaryVisibility", 0)

        # assign Shader
        cmds.hyperShade(assign=self.planeShader)

        # Find follicle Spacing
        self.follicleSpacing = (1 / float(self.joints))
        # print self.follicleSpacing

        # make Follicles, Attach to surface, and add joints
        for follicleNumber in range(0, self.joints):
            currentFlc = cmds.createNode('follicle', name=self.name + "_flc" + str(follicleNumber) + "_flc")
            cmds.connectAttr(self.baseplane[0] + ".local", currentFlc + ".inputSurface")
            cmds.connectAttr(self.baseplane[0] + ".worldMatrix[0]", currentFlc + ".inputWorldMatrix")
            cmds.connectAttr(currentFlc + ".outRotate", cmds.listRelatives(currentFlc, parent=True)[0] + ".rotate")
            cmds.connectAttr(currentFlc + ".outTranslate",
                             cmds.listRelatives(currentFlc, parent=True)[0] + ".translate")
            cmds.setAttr(currentFlc + ".parameterV", 0.5)
            cmds.setAttr(currentFlc + ".parameterU",
                         ((self.follicleSpacing / 2) + (self.follicleSpacing * follicleNumber)))
            self.follicles.append(currentFlc)
            self.folliclesTX.append(cmds.rename(cmds.listRelatives(currentFlc, parent=True)[0],
                                                self.name + "_flc" + str(follicleNumber) + "_flcTX"))
            self.jointList.append(
                cmds.joint(name="bind_" + currentFlc[:-4] + "_jnt", o=[90, 0, 0], rad=2 * self.follicleSpacing))
        cmds.select(self.folliclesTX)
        self.flcGroup = cmds.group(name=self.name + "_flc_grp")

        # Create End Controls
        self.ctrlCrvB = cmds.curve(d=1, ep=[(0, 0, 0), (.9, 0, 0), (.9, 0, .9), (0, 0, .9), (0, 0, 0)],
                                   name=self.name + "_cntB_ctr")
        cmds.xform(cp=True)
        cmds.xform(t=((self.distance / 2) - .45, 0, -0.45))

        self.ctrlCrvA = cmds.curve(d=1, ep=[(0, 0, 0), (.9, 0, 0), (.9, 0, .9), (0, 0, .9), (0, 0, 0)],
                                   name=self.name + "_cntA_ctr")
        cmds.xform(cp=True)
        cmds.xform(t=(-(self.distance / 2) - .45, 0, -0.45))

        # create Mid control
        self.ctrlCrvMid = cmds.curve(name=self.name + "_cntMid_ctr", d=1,
                                     p=[(-3.86937328, 0.0, 1.0), (-1.0, 0.0, 1.0), (-1.0, 0.0, 1.0), (-1.0, 0.0, 1.0),
                                        (-1.0, 0.0, 3.86937328), (-1.0, 0.0, 3.86937328), (-1.0, 0.0, 3.86937328),
                                        (-3.774758284e-15, -2.4492935980000003e-16, 4.0),
                                        (0.9999999993, -2.3693077960000004e-16, 3.869373271),
                                        (0.9999999993, -2.3693077960000004e-16, 3.869373271),
                                        (0.9999999993, -2.3693077960000004e-16, 3.869373271), (1.0, 0.0, 1.0),
                                        (1.0, 0.0, 1.0), (1.0, 0.0, 1.0), (3.86937328, 0.0, 1.0),
                                        (3.86937328, 0.0, 1.0), (3.86937328, 0.0, 1.0),
                                        (4.0, -3.5128962190000006e-31, 5.828670879e-15),
                                        (3.869373271, 6.123233991e-17, -0.9999999993),
                                        (3.869373271, 6.123233991e-17, -0.9999999993),
                                        (3.869373271, 6.123233991e-17, -0.9999999993), (1.0, 0.0, -1.0),
                                        (1.0, 0.0, -1.0), (1.0, 0.0, -1.0), (1.0, 0.0, -3.869373272),
                                        (1.0, 0.0, -3.869373272), (1.0, 0.0, -3.869373272),
                                        (-3.219646771e-15, 2.4492935980000003e-16, -4.0),
                                        (-0.9999999999, 2.3693077960000004e-16, -3.869373271),
                                        (-0.9999999999, 2.3693077960000004e-16, -3.869373271),
                                        (-0.9999999999, 2.3693077960000004e-16, -3.869373271), (-1.0, 0.0, -1.0),
                                        (-1.0, 0.0, -1.0), (-1.0, 0.0, -1.0), (-3.86937328, 0.0, -1.0),
                                        (-3.86937328, 0.0, -1.0), (-3.86937328, 0.0, -1.0),
                                        (-4.0, 5.854827031e-32, -8.881784197e-16), (-3.86937328, 0.0, 1.0)])
        cmds.xform(t=(0, 0, 0), s=(self.follicleSpacing, self.follicleSpacing, self.follicleSpacing))

        # freeze Transforms
        cmds.makeIdentity(self.ctrlCrvA, apply=True)
        cmds.makeIdentity(self.ctrlCrvB, apply=True)

        # create BlendShape Plane
        self.blendPlane = cmds.duplicate(self.baseplane, name=self.name + "_blendPlane_nrb")
        cmds.xform(self.blendPlane[0], t=(0, 0, -5))
        self.bShape = cmds.blendShape(self.blendPlane[0], self.baseplane[0], w=[(0, 1)], name=self.name + "_bshapeNode")
        # create wire deformer Wire
        self.defWire = cmds.curve(d=2, p=[(-self.distance / 2, 0, -5), (0, 0, -5), (self.distance / 2, 0, -5)],
                                  name=self.name + "_defWire_crv")
        self.defWireCrv = cmds.select(cmds.listRelatives(self.defWire, c=True, s=True)[0])
        self.defWireCrv = cmds.rename(self.defWireCrv, self.name + "_defWireCrv_crv")
        self.crvInfoSS = cmds.createNode("curveInfo", name=self.name + "_sscrvinfo_node")
        cmds.connectAttr(self.defWireCrv + ".worldSpace[0]", self.crvInfoSS + ".inputCurve")
        cmds.select(cl=True)

        # create Clusters

        cmds.select(self.defWire + ".cv[0]", self.defWire + ".cv[1]")
        self.clrA = cmds.cluster(rel=True, name=self.name + "_clrA_clr")
        cmds.move(-self.distance / 2, 0, -5, [self.clrA[1] + ".scalePivot", self.clrA[1] + ".rotatePivot"], a=True, )
        cmds.setAttr(self.clrA[0] + "HandleShape.origin", -(self.distance / 2) - self.follicleSpacing, 0, -5)
        cmds.select(cl=True)

        cmds.select(self.defWire + ".cv[1]", self.defWire + ".cv[2]")
        self.clrB = cmds.cluster(rel=True, name=self.name + "_clrB_clr")
        cmds.move(self.distance / 2, 0, -5, [self.clrB[1] + ".scalePivot", self.clrB[1] + ".rotatePivot"], a=True, )
        cmds.setAttr(self.clrB[0] + "HandleShape.origin", (self.distance / 2) + self.follicleSpacing, 0, -5)
        cmds.select(cl=True)

        cmds.select(self.defWire + ".cv[1]")
        self.clrMid = cmds.cluster(rel=True, name=self.name + "_clrMid_clr")
        cmds.select(cl=True)

        # adjust Cluster Wieght
        cmds.percent(self.clrA[0], self.defWire + ".cv[1]", v=.5)
        cmds.percent(self.clrB[0], self.defWire + ".cv[1]", v=.5)

        # create Wire deformer
        self.wiredef = cmds.wire(self.blendPlane[0], w=self.defWire, dds=(0, 10), name=self.name + "_wiredef")

        # connect cluseters to controls
        cmds.connectAttr(self.ctrlCrvA + ".translate", self.clrA[0] + "Handle.translate")
        cmds.connectAttr(self.ctrlCrvB + ".translate", self.clrB[0] + "Handle.translate")
        cmds.connectAttr(self.ctrlCrvMid + ".translate", self.clrMid[0] + "Handle.translate")
        cmds.select(cl=True)

        # center Mid COntrol
        self.midctrlgrp = cmds.group(self.ctrlCrvMid, name=self.ctrlCrvMid + "_pos_grp", a=True)
        cmds.xform(self.ctrlCrvMid, t=(0, 2, 0))
        cmds.makeIdentity(self.ctrlCrvMid, apply=True)
        cmds.move(0, 0, 0, [self.ctrlCrvMid + ".scalePivot", self.ctrlCrvMid + ".rotatePivot"], a=True)
        cmds.pointConstraint(self.ctrlCrvB, self.ctrlCrvA, self.midctrlgrp, name=self.midctrlgrp + "_cnst")
        self.lockHide(self.ctrlCrvMid, [".rx", ".ry", ".rz", ".sx", ".sy", ".sz"])

        # Group and organize
        cmds.select(cl=True)

        # Cluster Group
        cmds.select(self.clrMid, self.clrB, self.clrA)
        self.clrGroup = cmds.group(name=self.name + "_clr_grp")
        self.lockHideAll(self.clrGroup)
        cmds.select(cl=True)

        # Control Group
        cmds.select(self.ctrlCrvA, self.ctrlCrvB, self.midctrlgrp)
        cmds.xform([self.ctrlCrvA, self.ctrlCrvB], roo='xzy')
        self.cntsGroup = cmds.group(name=self.name + "_cnts_grp")
        self.lockHideAll(self.cntsGroup)
        self.turnYellow([self.ctrlCrvA, self.ctrlCrvB, self.ctrlCrvMid])
        cmds.select(cl=True)

        # Global Move Group
        cmds.select(self.cntsGroup, self.baseplane[0])
        self.moveGroup = cmds.group(name=self.name + "_globalMove_grp")
        cmds.move(0, 0, 0, [self.moveGroup + ".scalePivot", self.moveGroup + ".rotatePivot"], a=True)
        cmds.select(cl=True)

        # Extra Node Group
        cmds.select(self.clrGroup, self.flcGroup, self.blendPlane[0], self.defWire, self.defWire + "BaseWire")
        self.exNodesGroup = cmds.group(name=self.name + "_extraNodes_grp")
        cmds.move(0, 0, 0, [self.exNodesGroup + ".scalePivot", self.exNodesGroup + ".rotatePivot"], a=True)
        self.lockHideAll(self.exNodesGroup)
        cmds.select(cl=True)

        # Everything Group
        self.mainGroup = cmds.group(self.moveGroup, self.exNodesGroup, name=self.name + "_grp")
        cmds.move(0, 0, 0, [self.mainGroup + ".scalePivot", self.mainGroup + ".rotatePivot"], a=True)
        self.lockHideAll(self.mainGroup)
        cmds.select(cl=True)

        # fixing global move folicle scales
        for fol in self.folliclesTX:
            cmds.scaleConstraint(self.moveGroup, fol)

        # Create Global move Controler
        self.globalMoveCtr = cmds.circle(n=self.name + "_globalMove_ctr", r=self.follicleSpacing * 2,
                                         c=(0, 0, self.follicleSpacing * 2 + 1), nr=[0, 1, 0])
        circle2 = cmds.circle(n=self.name + "_2ndglobalMove_ctr", r=self.follicleSpacing * 2,
                              c=(0, 0, -self.follicleSpacing * 2 - 1), nr=[0, 1, 0])
        cmds.parent(circle2[0], self.globalMoveCtr[0])
        cmds.makeIdentity(a=1, t=1, r=1, s=1)
        shapes = cmds.listRelatives(circle2[0], s=True)
        for shape in shapes:
            cmds.parent(shape, self.globalMoveCtr[0], s=True, r=True)
        cmds.delete(circle2[0])
        cmds.delete(self.globalMoveCtr, ch=True)
        self.globalMoveCtr = self.globalMoveCtr[0]
        self.turnYellow(self.globalMoveCtr)
        cmds.parent(self.globalMoveCtr, self.mainGroup)
        cmds.parent(self.moveGroup, self.globalMoveCtr)
        cmds.select(cl=True)

        # create twist Deformer
        cmds.select(self.blendPlane)
        self.twistDeform = cmds.nonLinear(self.blendPlane, type='twist', name=self.name + "_twistDeform")
        self.twistDeform = cmds.ls(sl=True)
        self.twistDeformhdl = cmds.rename(self.twistDeform, self.name + "_twistDeform_hdl")
        cmds.xform(self.twistDeformhdl, ro=(0, 0, 90))
        self.twistInput = cmds.listConnections(self.twistDeformhdl + ".specifiedManipLocation", d=False, s=True)
        self.twistInput = cmds.rename(self.twistInput, self.name + "_twistDefInput")
        cmds.connectAttr(self.ctrlCrvB + ".rx", self.twistInput + ".startAngle")
        cmds.connectAttr(self.ctrlCrvA + ".rx", self.twistInput + ".endAngle")
        cmds.parent(self.twistDeformhdl, self.exNodesGroup)

        # change Deformer Order
        cmds.reorderDeformers(self.wiredef[0], self.twistInput, self.blendPlane)

        # Hide Extra Nodes
        cmds.hide(self.blendPlane[0], self.clrGroup, self.twistDeformhdl, self.defWire)
        for item in self.follicles:
            cmds.setAttr(item + ".v", 0)

        # Create Preserve volume nodes
        cmds.addAttr(self.globalMoveCtr, at="enum", ln="_", en="Squash and Stretch", k=True)
        cmds.addAttr(self.globalMoveCtr, at="enum", ln="Preserve_Volume", nn="Preserve Volume", en="Off:On", k=True)
        self.ssLengthNode = cmds.createNode("multiplyDivide", name=self.name + "_div_SS_length")
        cmds.setAttr(self.ssLengthNode + ".op", 2)
        cmds.connectAttr(self.crvInfoSS + ".arcLength", self.ssLengthNode + ".i1x")
        cmds.setAttr(self.ssLengthNode + ".i2x", self.distance)
        self.ssVolumeNode = cmds.createNode("multiplyDivide", name=self.name + "_div_SS_volume")
        cmds.setAttr(self.ssVolumeNode + ".i1x", 1)
        cmds.setAttr(self.ssVolumeNode + ".op", 2)
        cmds.connectAttr(self.ssLengthNode + ".ox", self.ssVolumeNode + ".i2x")
        self.ssCondNode = cmds.createNode("condition", name=self.name + "_ss_Cond")
        cmds.connectAttr(self.globalMoveCtr + ".Preserve_Volume", self.ssCondNode + ".firstTerm")
        cmds.setAttr(self.ssCondNode + ".secondTerm", 1)
        cmds.connectAttr(self.ssVolumeNode + ".ox", self.ssCondNode + ".ctr")

        # connect to joints
        for j in self.jointList:
            cmds.connectAttr(self.ssCondNode + ".ocr", j + ".sy")
            cmds.connectAttr(self.ssCondNode + ".ocr", j + ".sz")

    # lock/hide all Transforms on an object

    def lockHideAll(self, object):

        fullList = [".tx", ".ty", ".tz", ".rx", ".ry", ".rz", ".sx", ".sy", ".sz"]
        for attr in fullList:
            cmds.setAttr(object + attr, l=True, k=False, cb=False)
        print object + " fully Locked"

    # lock/hide all specifiedattribues on an object

    def lockHide(self, object, attList):
        for attr in attList:
            cmds.setAttr(object + attr, l=True, k=False, cb=False)

    # center Plane on locators
    def centerPlane(self):
        if len(self.selection) <= 1:
            pContraint = cmds.pointConstraint([self.itemLocators[0][0], self.itemLocators[1][0]], self.worldControl)
            aConstraint = cmds.aimConstraint(self.itemLocators[1], self.worldControl)
        else:
            pContraint = cmds.pointConstraint([self.selection[0], self.selection[1]], self.worldControl)
            aConstraint = cmds.aimConstraint(self.selection[1], self.worldControl)

        cmds.delete(aConstraint)
        print "Placed"
        return

    # bind plane to start and End objects

    def bindPlane(self):
        if len(self.selection) <= 1:
            print "Bind it yourself!"
            cmds.delete(self.defLine, self.itemLocators[0], self.itemLocators[1], self.worldControl)
        else:
            cmds.parentConstraint(self.selection[0], self.ctrlCrvA)
            cmds.parentConstraint(self.selection[1], self.ctrlCrvB)
            cmds.delete(self.defLine, self.itemLocators[0], self.itemLocators[1])
            cmds.parent(self.globalMoveCtr, self.worldControl)
            cmds.xform(self.globalMoveCtr, ro=(0, 0, 0), t=(0, 0, 0), s=(1, 1, 1))

        self.lockHideAll(self.baseplane[0])
        print "Connected"
        return

    # make Plane Shader
    def makeShader(self):
        if not cmds.objExists(self.name + "_sdr"):
            self.planeShader = cmds.shadingNode('aiStandardSurface', asShader=True, name=self.name + "_sdr")
        else:
            self.planeShader = self.name + "_sdr"
        cmds.setAttr(self.planeShader + ".specular", 0)
        cmds.setAttr(self.planeShader + ".opacityR", 0.05)
        cmds.setAttr(self.planeShader + ".opacityG", .8)
        cmds.setAttr(self.planeShader + ".opacityB", 0.05)
        cmds.setAttr(self.planeShader + ".baseColorR", .6)
        cmds.setAttr(self.planeShader + ".baseColorG", 1)
        cmds.setAttr(self.planeShader + ".baseColorB", .6)
        return

    # turn controlers yellow
    def turnYellow(self, items):
        cmds.select(items)
        everything = cmds.ls(sl=True)
        for item in everything:
            Children = cmds.listRelatives(c=True, shapes=True)
            for child in Children:
                cmds.setAttr(child + ".overrideEnabled", 1)
                cmds.setAttr(child + ".overrideColor", 17)
        cmds.select(cl=True)

def ribbonUI(*args):
    #UI for Ribbon Class
    if cmds.window('RibbonUI', exists=True):
        cmds.deleteUI('RibbonUI')
    ribWin = cmds.window('RibbonUI', title='Spawn Ribbon')
    ribWinlayout = cmds.gridLayout(numberOfColumns=1, cellWidthHeight=(300, 50))
    Titles = cmds.text(
        'Select 2 Objects and create to spawn connected ribbon \nor\n Click create to just spawn a ribbon or length at origin. ')
    ribbonname = cmds.textFieldGrp(cw2=(50, 100), columnAlign=[[1, "left"], [2, "left"]], l="Name", tx="Default")
    jointSlider = cmds.intSliderGrp(cw3=(50, 50, 25), columnAlign=[[1, "left"], [2, "left"]], label='Joints', min=1,
                                    fmn=1, field=True, v=5)
    opps = "print \'Oops!\'"
    lengthSlider = cmds.floatSliderButtonGrp(cw4=(50, 50, 25, 50), columnAlign=[[1, "left"], [2, "left"]],
                                             label='Length', min=1, fmn=1, field=True, v=10, bl="Don't Click", bc=opps)
    btncommand = partial(ribUIrun, jointSlider, lengthSlider, ribbonname)
    cmds.button("Create", l="Create", c=btncommand)
    cmds.showWindow(ribWin)

def ribUIrun(joints, length, name, huh):
    #UI helper function
    jointsNeeded = cmds.intSliderGrp(joints, q=True, v=True)
    lengthNeeded = cmds.floatSliderButtonGrp(length, q=True, v=True)
    nameNeeded = cmds.textFieldGrp(name, q=True, tx=True)
    createdRibbon = ribbon(binditems=cmds.ls(sl=True), joints=jointsNeeded, size=lengthNeeded, name=nameNeeded)

####################################################################################################################################################################################################################################################################################################


class InstantShader(object):
    '''
    This is the Base Class for which all the other shaders are derived from.

    Usage Instructions
    ----------
    No direct Usage

    Parameters
    ----------
    Shader Object

    Returns
    -------
    NONE
    '''

    def __init__(self):

        self.supportedextentions = ['jpg','gif','png','tif','bmp']
        self.selection = pm.ls(sl=True)
        print self.selection
        self.name = os.path.basename(self.folder)
        self.files = os.listdir(self.folder)
        print self.files
        self.filelist = []
        self.mapDict ={}
        self.filenodes = []

    def connectFileNodes(self,item): #Connect up file nodes
        texture = item
        print texture
        if texture.split('_')[0] in self.cmapAttr.keys():
            attribute = str(self.createdShader[0]+'.'+self.cmapAttr[texture.split('_')[0]])
            try:
                print attribute
                pm.connectAttr(texture.outColor, attribute)
            except:
                print attribute
                pm.connectAttr(texture.outAlpha, attribute)

        if texture.split('_')[0] == 'Norm':
                attribute = str(self.createdShader[0]+'.normalCamera')
                bump2dnode = pm.shadingNode('bump2d',name='Normal_%s'%texture.split('_')[1], asUtility=True)
                pm.connectAttr(texture.outAlpha, bump2dnode.bumpValue)
                pm.connectAttr(bump2dnode.outNormal,attribute)
                pm.setAttr(bump2dnode.bumpInterp, 2)

        if texture.split('_')[0] == 'Bump':
                attribute = str(self.createdShader[0]+'.normalCamera')
                bump2dnode = pm.shadingNode('bump2d',name='Bump_%s'%texture.split('_')[1], asUtility=True)
                pm.connectAttr(texture.outAlpha, bump2dnode.bumpValue)
                pm.connectAttr(bump2dnode.outNormal,attribute)

        if texture.split('_')[0] == 'Disp':
               attribute = str(self.createdShader[1]+'.displacementShader')
               disp2dnode = pm.shadingNode('displacementShader',name='Disp_%s'%texture.split('_')[1], asUtility=True)
               pm.connectAttr(texture.outAlpha, disp2dnode.displacement)
               pm.connectAttr(disp2dnode.displacement,attribute)



    def processFolder(self): #parse files in folder and either fix the prefix or connect up the file nodes'
        for item in self.files:
            if '.' in item:
                if (item.split('.')[1]) in self.supportedextentions:
                    self.filelist.append(item)
        for item in self.filelist:
            if item.split('_')[0] in self.mapDict.keys():
                self.mapDict[item.split('_')[0]] = item
                self.connectFileNodes(self.processtex(item))
            else:
                self.fixPrefix(item)



    def AddPrefix(self,item,premenu,windows,*args): #adds a prefix if needed
        prefix = premenu.getValue()
        if prefix != 'Skip':
            print item
            print prefix
            print 'worked'
            newthing = self.folder+'/'+prefix+'_'+item
            oldthing = self.folder+'/'+item
            print oldthing
            print newthing
            os.rename(oldthing,newthing)
            pm.deleteUI(windows, window=True)
            self.mapDict[prefix] = str(prefix+'_'+item)
            print item
            newnode = self.processtex(self.mapDict[prefix])
            self.connectFileNodes(newnode)
        else:
            print 'skipped'
            pm.deleteUI(windows, window=True)



    def fixPrefix(self,item): #Prompts User For Prefixes

        print 'broke',item
        fixprefixwindow = pm.window()
        layout = pm.columnLayout()
        title = pm.text(label = 'The file %s does not have the correct prefix \n Please select the correct one below or Skip.'%(item))
        prefixMenu = pm.optionMenu(label='Correct Prefix?')
        skip = pm.menuItem( label='Skip')
        for option in self.mapDict.keys():
            pm.menuItem( label=option )
        SubmitButton = pm.button(label ='Submit',c =Callback(self.AddPrefix,item,prefixMenu,fixprefixwindow))
        close = pm.button(label='Close', command=('pm.deleteUI(\"' +fixprefixwindow + '\", window=True)') )
        pm.showWindow(fixprefixwindow)


    def processtex(self,item): #Connect place 2d Texture nodes to File Nodes)

        fileTruename = item.split(".")
        fileNode = pm.shadingNode('file',name='%s'%fileTruename[0], asTexture=True)
        fullfile = self.folder + '\\' + item
        fileNode.setAttr('fileTextureName',str(fullfile))
        p2d = pm.shadingNode('place2dTexture', name='is2d%s'%fileTruename[0], asUtility=True)
        fileNode.filterType.set(0)
        pm.connectAttr(p2d.outUV, fileNode.uvCoord)
        pm.connectAttr(p2d.outUvFilterSize, fileNode.uvFilterSize)
        pm.connectAttr(p2d.vertexCameraOne, fileNode.vertexCameraOne)
        pm.connectAttr(p2d.vertexUvOne, fileNode.vertexUvOne)
        pm.connectAttr(p2d.vertexUvThree, fileNode.vertexUvThree)
        pm.connectAttr(p2d.vertexUvTwo, fileNode.vertexUvTwo)
        pm.connectAttr(p2d.coverage, fileNode.coverage)
        pm.connectAttr(p2d.mirrorU, fileNode.mirrorU)
        pm.connectAttr(p2d.mirrorV, fileNode.mirrorV)
        pm.connectAttr(p2d.noiseUV, fileNode.noiseUV)
        pm.connectAttr(p2d.offset, fileNode.offset)
        pm.connectAttr(p2d.repeatUV, fileNode.repeatUV)
        pm.connectAttr(p2d.rotateFrame, fileNode.rotateFrame)
        pm.connectAttr(p2d.rotateUV, fileNode.rotateUV)
        pm.connectAttr(p2d.stagger, fileNode.stagger)
        pm.connectAttr(p2d.translateFrame, fileNode.translateFrame)
        pm.connectAttr(p2d.wrapU, fileNode.wrapU)
        pm.connectAttr(p2d.wrapV, fileNode.wrapV)
        print fileNode,' connected'
        return fileNode

    def applyShader(self):
        if len(self.selection) > 0:
            for item in self.selection:
                pm.select(item)
                print 'item is',item
                pm.hyperShade(a=self.createdShader)

#Subclass for Arnold AI Standard shader
class InstantaiStandardSurface(InstantShader):
    '''	Instant AI Standard Surface Shader
        By Charles Kinter
        Usage assign variable to InstantaiStandardSurface(PATH) where PATH is a string to your folder of textures'''
    def __init__(self,folder):
        self.folder = folder
        super(InstantaiStandardSurface,self).__init__()
        self.mapDict= {'DifC':'','DifR':'','Metl':'','SpeC':'','TraC':'','SubC':'','CoaC':'','CoaR':'','EmiC':'','EmiW':'','Opac':'','Bump':'','Norm':'','Disp':''}
        self.cmapAttr ={'DifC':'baseColor','DifR':'diffuseRoughness','Metl':'metalness','SpeC':'specularColor','TraC':'transmissionColor','SubC':'subsurfaceColor','CoaC':'coatColor','CoaR':'coatRoughness','EmiC':'emissionColor','EmiW':'emission','Opac':'opacity'}
        self.createdShader = pm.createSurfaceShader('aiStandardSurface',name=self.name)
        self.processFolder()
        for item in self.filenodes:
            print item
            self.connectFileNodes(item)
        self.applyShader()

#Subclass for Blinn shader
class InstantBlinn(InstantShader):
    '''	Instant Blinn Shader
		By Charles Kinter
		Usage assign variable to InstantaiStandardSurface(PATH) where PATH is a string to your folder of textures'''

    def __init__(self, folder):
        self.folder = folder
        super(InstantBlinn, self).__init__()
        self.mapDict = {'Bump': '', 'Norm': '', 'Disp': '', 'Color': '', 'Incd': '', 'SpeC': '', 'Tran': '', 'AmbC': '',
                        'RefC': ''}
        self.cmapAttr = {'Color': 'color', 'Incd': 'incandescence', 'SpeC': 'specularColor', 'Tran': 'transparency',
                         'AmbC': 'ambientColor', 'RefC': 'reflectedColor'}
        self.createdShader = pm.createSurfaceShader('blinn', name=self.name)
        self.processFolder()
        for item in self.filenodes:
            print item
            self.connectFileNodes(item)
        self.applyShader()

#Subclass for Phong shader
class InstantPhong(InstantShader):
    '''	Instant Phong Shader
		By Charles Kinter
		Usage assign variable to InstantaiStandardSurface(PATH) where PATH is a string to your folder of textures'''

    def __init__(self, folder):
        self.folder = folder
        super(InstantPhong, self).__init__()
        self.mapDict = {'Bump': '', 'Norm': '', 'Disp': '', 'Color': '', 'Incd': '', 'SpeC': '', 'Tran': '', 'AmbC': '',
                        'RefC': ''}
        self.cmapAttr = {'Color': 'color', 'Incd': 'incandescence', 'SpeC': 'specularColor', 'Tran': 'transparency',
                         'AmbC': 'ambientColor', 'RefC': 'reflectedColor'}
        self.createdShader = pm.createSurfaceShader('phong', name=self.name)
        self.processFolder()
        for item in self.filenodes:
            print item
            self.connectFileNodes(item)
        self.applyShader()

#Subclass for Lambert shader
class InstantLambert(InstantShader):
    '''	Instant Lambert Shader
		By Charles Kinter
		Usage assign variable to InstantaiStandardSurface(PATH) where PATH is a string to your folder of textures'''

    def __init__(self, folder):
        self.folder = folder
        super(InstantLambert, self).__init__()
        self.mapDict = {'Bump': '', 'Norm': '', 'Disp': '', 'Color': '', 'Incd': '', 'SpeC': '', 'Tran': '', 'AmbC': '',
                        'RefC': ''}
        self.cmapAttr = {'Color': 'color', 'Incd': 'incandescence', 'SpeC': 'specularColor', 'Tran': 'transparency',
                         'AmbC': 'ambientColor', 'RefC': 'reflectedColor'}
        self.createdShader = pm.createSurfaceShader('lambert', name=self.name)
        self.processFolder()
        for item in self.filenodes:
            print item
            self.connectFileNodes(item)
        self.applyShader()

#Instant Shader UI Window
def iscWindow(*args):
    '''
    this script Creates the UI for the instant Shader Classes
    Usage Instructions
    ----------
    Run Command to launch UI

    Parameters
    ----------
    Returns
    -------
    NONE
    '''

    from pymel.all import Callback
    shaderlist = {'Blinn':'InstantBlinn','Lambert':'InstantLambert','Phong':'InstantPhong','Arnold aiStandardSurface':'InstantaiStandardSurface'}
    if pm.window('instantUi',exists=True):
        pm.deleteUI('instantUi')
    iscWin = pm.window('instantUi',title='Create Shader From Folder.')
    iscWinlayout = pm.columnLayout()
    iscWintitle = pm.text(label = 'Please select the type of Instant Shader you wish to create.')
    folder = pm.folderButtonGrp()
    iscMenu = pm.optionMenu('iscMenu',label='Shader Type?')
    skipoption = pm.menuItem( label='Skip' )
    for option in shaderlist.keys():
        pm.menuItem( label=option )
    pm.optionMenu('iscMenu',edit=True,value='Skip')
    SubmitButton = pm.button(label ='Create',c = Callback(getvalues,iscMenu,folder,shaderlist))
    close = pm.button(label='Close', command=('pm.deleteUI(\"' +iscWin + '\", window=True)') )
    pm.showWindow(iscWin)

#This function updates the values form the instant shader Ui window and funnels them into a command.
def getvalues(option,path,prefix):
    '''
    This script gets values from UI and runs command.
    Usage Instructions
    ----------
    Run from UI

    Parameters
    ----------
    option :UI Object
    path  :UI Object
    prefix  :UI Object

    Returns
    -------
    NONE
    '''
    if option.getValue() == 'Skip':
        return
    isccommand = prefix[option.getValue()]
    iscpath= path.getText()
    isccommand = isccommand +'(\''+iscpath+'\')'
    bob = eval(isccommand)
    print type(bob)


####################################################################################################################################################################################################################################################################################################
#            Script Tools
####################################################################################################################################################################################################################################################################################################

####################################################################################################################################################################################################################################################################################################

def lockHide(object, attList):
    '''
    This simple script to lock and hide all attributes in specified list.

    Usage Instructions
    ----------
    lockHide(object,[attList])

    Parameters
    ----------
    object : STRING
    attList : LIST

    Returns
    -------
    NONE

    '''
    for attr in attList:
        cmds.setAttr(object + attr, l=True, k=False, cb=False)

####################################################################################################################################################################################################################################################################################################

def circlethere(radius=5,*args):
    '''
    This script will place a circle control parented under the selection.

    Usage Instructions
    ----------
    Select object(s), run circlethere()


    Parameters
    ----------
    NONE


    Returns
    -------
    controls: LIST
    List of all circles made on selected objects.

    '''
    everything = cmds.ls(sl=True)
    controls = []
    if len(everything) != 0 :
        for item in everything:
            cmds.select(cl=True)
            newcircle = cmds.circle(name=item+"_ctr",r=radius)
            cmds.parent(newcircle,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newcircle[0])
    return  controls



####################################################################################################################################################################################################################################################################################################

def buildBindJointsFromLocs(*args):
    '''
    This function Builds a joint heirachy matching the one the item selected is the parent of.

    Usage Instructions
    ----------
    Select a transform in a heirarchy and run script.

    ----------
    NONE

    Returns
    -------
    joints : LIST

    '''
    ends = []
    joints = []
    current = cmds.ls(sl=True)

    if len(current) < 1:
        print 'less'
        return
    cmds.select(cl=True)
    thisjoint = cmds.joint(name="bind_"+current[0] + "_jnt")
    joints.append(thisjoint)
    cmds.select(cl=True)
    tempconstraint = cmds.parentConstraint(current[0], thisjoint, mo=False)
    cmds.delete(tempconstraint)
    #find heirarchy function
    def buildHeiarchy(start):
        current = start
        if len(joints) > 0:
            lastJoint = joints[-1]
        else:
            lastJoint = start
        test = cmds.listRelatives(current, type="transform",pa=True)
        if test != None:
            children = (cmds.listRelatives(current, type="transform",pa=True))
            for child in children:
                cmds.select(cl=True)
                thisjoint = cmds.joint(name="bind_"+child + "_jnt")
                joints.append(thisjoint)
                cmds.select(cl=True)
                tempconstraint = cmds.parentConstraint(child, thisjoint, mo=False)
                cmds.delete(tempconstraint)
                cmds.select(cl=True)
                cmds.parent(thisjoint,lastJoint)
                reorientJntTool()

                buildHeiarchy(child)
        else:
            ends.append(lastJoint)

    buildHeiarchy(current[0])
    cmds.select(joints[0])
    cmds.joint(joints[0],e=True, oj="xzy", ch=True)
    cmds.select(ends)
    reorientJntTool()
    return joints


####################################################################################################################################################################################################################################################################################################
def turnRed(*args):
    '''
    Turns selected Nurbs Curves Red

    Usage Instructions
    ----------
    Selct Curves, run script


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    for item in everything:
        Children = cmds.listRelatives(c=True, shapes=True)
        for child in Children:
            cmds.setAttr(child + ".overrideEnabled", 1)
            cmds.setAttr(child + ".overrideColor", 13)


def turnBlue(*args):
    '''
    Turns selected Nurbs Curves Blue

    Usage Instructions
    ----------
    Seelct Curves, run script


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    for item in everything:
        Children = cmds.listRelatives(c=True, shapes=True)
        for child in Children:
            cmds.setAttr(child + ".overrideEnabled", 1)
            cmds.setAttr(child + ".overrideColor", 6)


def turnYellow(*args):
    '''
    Turns selected Nurbs Curves Yellow

    Usage Instructions
    ----------
    Seelct Curves, run script


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    for item in everything:
        Children = cmds.listRelatives(c=True, shapes=True)
        for child in Children:
            cmds.setAttr(child + ".overrideEnabled", 1)
            cmds.setAttr(child + ".overrideColor", 17)


def turnGreen(*args):
    '''
    Turns selected Nurbs Curves Green

    Usage Instructions
    ----------
    Seelct Curves, run script


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    for item in everything:
        Children = cmds.listRelatives(c=True, shapes=True)
        for child in Children:
            cmds.setAttr(child + ".overrideEnabled", 1)
            cmds.setAttr(child + ".overrideColor", 14)

def pickShapeColor(*args):
    '''
    This Script enables drawing overides, and creates an attribute on the main transform that is connected to all the shapes overide color channel for each shape under the transform.

    Usage Instructions
    ----------
    Selct Curves, run script


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE

    '''

    everything = cmds.ls(sl=True)
    for item in everything:
        Shapes = cmds.listRelatives(item,s=True)
        cmds.select(cl=True)
        cmds.select(item)
        if (cmds.attributeQuery("ControlColorindex",n=item,ex=True)!=True):
            cmds.addAttr(longName="ControlColorindex", attributeType="long",keyable=True)
        for thing in Shapes:
            oldColor = cmds.getAttr(thing+".overrideColor")
            cmds.setAttr(thing+".overrideEnabled",1)
            cmds.connectAttr(item+".ControlColorindex",thing+".overrideColor",f=True)
            cmds.setAttr(item+".ControlColorindex",oldColor)




def clrUI(*args):
    '''
    Simple UI for color Changes

    Usage Instructions
    ----------
    Run Script, it then calls the requested change color script.


    Parameters
    ----------
    NONE


    Returns
    -------
     NONE
    '''
    if cmds.window('ColorMyRig', exists=True):
        cmds.deleteUI('ColorMyRig')
    rigWin = cmds.window('ColorMyRig', title='Color Rigging Controls')
    rigWinlayout = cmds.columnLayout()
    Titles = cmds.text('Select Object and click button to Color control')
    ctrlgrid = cmds.gridLayout("cnts_Grid", numberOfRowsColumns=(1, 4), cellWidthHeight=(70, 50))
    orderbuttons = [["Red", turnRed], ["Blue", turnBlue], ["Yellow", turnYellow], ["Green", turnGreen]]
    for item in orderbuttons:
        print item
        cmds.button(item[0], l=item[0], p=ctrlgrid, c=item[1])
    cmds.showWindow(rigWin)


####################################################################################################################################################################################################################################################################################################

def makeEyeJoint(*args):
    '''
    This makes a series of Joints with root joints at the selected center. Useful in creating fix length joins like to an eye center.

    Usage Instructions
    ----------
    Select transforms to be used as joint locations, then select a transform where the center should be.

    Parameters
    ----------
    NONE

    Returns
    -------
    madeJoints : LIST

    '''
    everything = cmds.ls(sl=True,fl=True)[:-1]
    locators = []
    madeJoints =[]
    center = cmds.ls(sl=True,fl=True,tl=1)[0]
    if len(everything) != 0 :
        for v in everything:
            cmds.select(cl=True)
            loc =cmds.xform(v,q=1,ws=1,t=1)
            locC = cmds.xform(center,q=1,ws=1,t=1)
            currrentJoint = cmds.joint(name=v+"_jnt",p=loc)
            madeJoints.append(currrentJoint)
            cmds.select(cl=True)
            centerJoint = cmds.joint(name=v+"_center_jnt",p=locC)
            cmds.parent(currrentJoint,centerJoint)
            cmds.joint(centerJoint,e=1,oj="xyz",sao="yup",ch=1,zso=1)
            cmds.select(currrentJoint)
            reorientJntTool()
            cmds.select(cl=True)

    return madeJoints

####################################################################################################################################################################################################################################################################################################

def makeAims(*args):
    '''
    This script creates a locator and sets up an aim constraint one Joint up the chain from selection. Useful in controling fix length joints.

    Usage Instructions
    ----------
    Select end joints. Run Script.


    Parameters
    ----------
    NONE


    Returns
    -------
    newlocs : LIST

    '''
    everything = cmds.ls(sl=True)
    if len(everything) != 0 :
        newlocs = []
        for item in everything:
            locator = cmds.spaceLocator(name=item+"_loc")
            constraint = cmds.pointConstraint(item,locator)
            cmds.delete(constraint)
            par = cmds.listRelatives(item,p=1)[0]
            cmds.aimConstraint(locator,par,mo=1,weight =1, aimVector = (1,0,0),upVector = (0,1,0))

            newlocs.append(locator)
        return newlocs

####################################################################################################################################################################################################################################################################################################

def makeCurveFromSel(curveDeg = 3,*args):
    '''
    This script takes a selection of transforms and draws a curve with an ep at each location. This is useful when setting up motion paths for chains and cords or for routing cables.

    Usage Instructions
    ----------
    Select a series of transforms, Run script.


    Parameters
    ----------
    curveDeg : INT
    Set to 1 or 3, depending on curve need.


    Returns
    -------
    newcurve : LIST

    '''
    everything = cmds.ls(sl=True)
    points =[]
    if len(everything) != 0 :
        for item in everything:
            cmds.select(cl=True)
            cmds.select(item)
            locator = makeCtrLocators()
            try:
                pos = cmds.getAttr(locator[0]+".t")[0]
            except:
                print  "Error"
            points.append(pos)
            cmds.delete(locator)
        print points
        newcurve = cmds.curve(ep=points,d=curveDeg)
        return newcurve

####################################################################################################################################################################################################################################################################################################



def pinToCrv(*args):
    '''
    This script with take transforms aligned on a curve a pin them to the curve keeping
    their location constant on the curve

    Usage Instructions
    ----------
    Select transforms to bind, then select curve to bind it to.


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE


    '''
    crv = cmds.ls(sl=True,tl=1)[0]
    print crv
    sel = cmds.ls(sl=True)[:-1]
    print sel
    for item in sel:
        pos = cmds.xform(item, q=1,ws=1,t=1)
        u = getUParam(pnt=pos,crv=crv)
        print u
        name = item.replace("_loc","_PCI")
        pci = cmds.createNode("pointOnCurveInfo", n=name)
        print pci
        cmds.connectAttr(crv + ".worldSpace",pci+".inputCurve")
        cmds.setAttr(pci+".parameter",u)
        cmds.connectAttr(pci+".position",item+".t")



'''Below Provided by Training at https://vimeo.com/66583205 by Marco Giordano'''
def getUParam( pnt = [], crv = None):
    '''
    Helper Script for finding transform locations on the curve.

    Usage Instructions
    ----------
    Feed it list of transforms and the curve.


    Parameters
    ----------
    pnt: LIST
    crv : NURBSCURVE



    Returns
    -------
    param : U location

    '''

    point = OpenMaya.MPoint(pnt[0],pnt[1],pnt[2])
    curveFn = OpenMaya.MFnNurbsCurve(getDagPath(crv))
    paramUtill=OpenMaya.MScriptUtil()
    paramPtr=paramUtill.asDoublePtr()
    isOnCurve = curveFn.isPointOnCurve(point)
    if isOnCurve == True:

        curveFn.getParamAtPoint(point , paramPtr,0.001,OpenMaya.MSpace.kObject )
    else :
        point = curveFn.closestPoint(point,paramPtr,0.001,OpenMaya.MSpace.kObject)
        curveFn.getParamAtPoint(point , paramPtr,0.001,OpenMaya.MSpace.kObject )

    param = paramUtill.getDouble(paramPtr)
    return param

def getDagPath( objectName):
    '''
    Second Helper Script for pinToCrv

    Returns
    -------
    exact node for getUParam
    '''

    if isinstance(objectName, list)==True:
        oNodeList=[]
        for o in objectName:
            selectionList = OpenMaya.MSelectionList()
            selectionList.add(o)
            oNode = OpenMaya.MDagPath()
            selectionList.getDagPath(0, oNode)
            oNodeList.append(oNode)
        return oNodeList
    else:
        selectionList = OpenMaya.MSelectionList()
        selectionList.add(objectName)
        oNode = OpenMaya.MDagPath()
        selectionList.getDagPath(0, oNode)
        return oNode


####################################################################################################################################################################################################################################################################################################

def curveEPsToJnts(*args):
    '''
    This Script places joints at each EP of a curve.

    Usage Instructions
    ----------
    Select curve, run script.


    Parameters
    ----------
    NONE

    Returns
    -------
    jointgrp : LIST

    '''
    selectedCurve = cmds.ls(sl=True)
    madeJoint =[]
    curveCV = cmds.ls(selectedCurve[0]+".ep[0:]",fl=True)
    for cv in curveCV:
        cvPos = cmds.xform(cv,q=1,ws=1,t=1)
        cmds.select(cl=True)
        currentJOint = cmds.joint(p=cvPos)
        madeJoint.append(currentJOint)
    cmds.select(cl=True)
    cmds.select(madeJoint)
    jointgrp = cmds.group(name=selectedCurve[0]+"_Joints")

    return jointgrp

#####################################################################################################################################################################################################################################################################################################

def fixLRA(*args):
    '''
    Turns off local rotation axis of selection.

    Usage Instructions
    ----------
    Select items, run script.


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE
    '''
    selection = cmds.ls(sl=True,type = "joint")
    for item in selection:
       cmds.setAttr(item+".displayLocalAxis",0)

#####################################################################################################################################################################################################################################################################################################

def fixLOC(*args):
    '''
    This script hides visible locators in the scene

    Usage Instructions
    ----------
    Run script.


    Parameters
    ----------
    NONE

    Returns
    -------
    NONE

    '''
    cmds.select(ado=True)
    selection = cmds.ls(type="locator")
    print selection
    for item in selection:
        cmds.setAttr(item + ".visibility", 0)

#####################################################################################################################################################################################################################################################################################################
def unfixLOC(*args):
    '''
    Turns Locator Viability on for the Scene

    Usage Instructions
    ----------
    Run command to turn on locator shape vviability


    Parameters
    ----------
    NONE



    Returns
    -------
    NONE


    '''
    cmds.select(ado=True)
    selection = cmds.ls(type="locator")
    print selection
    for item in selection:
        cmds.setAttr(item + ".visibility", 1)

#####################################################################################################################################################################################################################################################################################################


def makeclstrPointCtrl(exp=3,*args):
    '''
    This creates a cluster contorl from the selected vertexes. It will expand the selection by the exp value before making the cluster.

    Usage Instructions
    ----------
    Select vertex(s) where you want cluster control(s), run script.


    Parameters
    ----------
    exp : INT
    how many times to expand the selection.



    Returns
    -------
    controls: LIST

    '''
    everything = cmds.ls(sl=True)
    locators = []
    verts = []
    clusters = []
    if len(everything) != 0 :
        for vert in everything:
            cmds.select(cl=True)
            cmds.select(vert)
            for expand in range(0,exp):
                cmds.polySelectConstraint(pp=1)
            clusters.append(cmds.cluster()[1])

    if len(everything) != 0 :
        for item in clusters:
            locator = cmds.spaceLocator(name=item+"_loc")
            constraint = cmds.parentConstraint(item,locator)
            cmds.delete(constraint)
            cmds.xform(a=True,ro=[0,0,0])
            locators.append(locator[0])
    if len(locators) != 0 :
        controls = []
        for item in locators:
            newsphere = cmds.sphere(r=.5,name=item+"_ctr")
            cmds.parent(newsphere,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newsphere[0])
    for cont in range(0,len(everything)):
        cmds.pointConstraint(controls[cont],clusters[cont])
    return controls


def makeclstrPointCtrlprompt(*args):
    '''
    Helper UI for makeclstrPointCtrl. Gives window access tot he exp variable.

    Usage Instructions
    ----------
    Select vertices, run script.


    Parameters
    ----------
    NONE


    Raises
    ------
    VALUEERROR : when inproper entry is made, runs at default.

    Returns
    -------
    NONE

    '''
    rigname = cmds.promptDialog(title='Grow Selection by how much?',message='Enter Integer:',	button=['OK', 'Cancel'],defaultButton='OK',cancelButton='Cancel',dismissString='Cancel')
    if rigname == 'OK':
        try:
            expand = int(cmds.promptDialog(query=True, text=True))
            makeclstrPointCtrl(exp=expand)
        except:
            makeclstrPointCtrl()

#####################################################################################################################################################################################################################################################################################################

def makePointCtrl(*args):
    '''
    Make A Sphere control that is point constrained to selection.

    Usage Instructions
    ----------
    select objects to constrain, run script.


    Parameters
    ----------
    NONE


    Returns
    -------
    controls : LIST



    '''
    everything = cmds.ls(sl=True)
    locators = []
    if len(everything) != 0 :
        for item in everything:
            locator = cmds.spaceLocator(name=item+"_loc")
            constraint = cmds.parentConstraint(item,locator)
            cmds.delete(constraint)
            cmds.xform(a=True,ro=[0,0,0])
            locators.append(locator[0])
    if len(locators) != 0 :
        controls = []
        for item in locators:
            newsphere = cmds.sphere(r=.5,name=item+"_ctr")
            cmds.parent(newsphere,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newsphere[0])
    for cont in range(0,len(everything)):
        cmds.pointConstraint(controls[cont],everything[cont])
    return controls

#####################################################################################################################################################################################################################################################################################################

def makeVertJointCtrl(*args):
    '''
    This places a joint at each selected vertex then makes a sphere control object on it to control it. Useful for setting up face controls.

    Usage Instructions
    ----------
    Select vertices, run script.


    Parameters
    ----------
    NONE


    Returns
    -------
    controls : List

    '''
    everything = cmds.ls(sl=True,fl=True)
    locators = []
    joints =[]
    if len(everything) != 0 :
        for v in everything:
            cmds.select(cl=True)
            pos =cmds.xform(v,q=1,ws=1,t=1)
            currrentJoint = cmds.joint(p=pos)
            joints.append(currrentJoint)
    if len(everything) != 0 :
        for item in joints:
            locator = cmds.spaceLocator(name=item+"_loc")
            constraint = cmds.parentConstraint(item,locator)
            cmds.delete(constraint)
            cmds.xform(a=True,ro=[0,0,0])
            locators.append(locator[0])
    if len(locators) != 0 :
        controls = []
        for item in locators:
            newsphere = cmds.sphere(r=.5,name=item+"_ctr")
            cmds.parent(newsphere,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newsphere[0])
    for cont in range(0,len(everything)):
        cmds.pointConstraint(controls[cont],joints[cont])
    return controls

#####################################################################################################################################################################################################################################################################################################

def curveCVsToCtrls(*args):
    '''
    This sciptr makes clusters at the cvs of a curve then binds control circles to them.

    Usage Instructions
    ----------
    select curve, Run Script


    Parameters
    ----------
    NONE


    Returns
    -------
    controls : LIST

    '''
    selectedCurve = cmds.ls(sl=True)
    cvClusters = []
    ctrls = []
    madeClusters = []
    curveCV = cmds.ls(selectedCurve[0] + ".cv[0:]", fl=True)
    for cv in curveCV:
        currentCluster = cmds.cluster([cv])
        madeClusters.append(currentCluster[1])
        newcircle = cmds.circle(name=selectedCurve[0] + "_ctr")
        ctrls.append(newcircle[0])
        constraint = cmds.parentConstraint(currentCluster, newcircle)
        cmds.delete(constraint)
        cmds.pointConstraint(newcircle, currentCluster)

    cmds.select(ctrls)
    cmds.group(name=selectedCurve[0] + "_ctrls")
    cmds.select(cl=True)
    cmds.select(madeClusters)
    cmds.group(name=selectedCurve[0] + "_clusters")
    return ctrls


#####################################################################################################################################################################################################################################################################################################


def lockHide(object, attList):
    '''
    A simple Help script to lock and hide attributes on an object.

    Usage Instructions
    ----------
    run lockHide(object,attList)



    Parameters
    ----------
    object: STRING
    object to lock hide on.

    attList : lIST
    list of attributes to lock and hide.


    Returns
    -------
    NONE

    '''
    for attr in attList:
        cmds.setAttr(object + attr, l=True, k=False, cb=False)

####################################################################################################################################################################################################################################################################################################

def circlethere(rad = 2,*args):
    '''
    This is a simple script to put a circle parented under the selection. When used with the create locators script it makes simple controls.

    Usage Instructions
    ----------
    Select transform, run script.


    Parameters
    ----------
    rad : FLOAT
    radius of circle

    Returns
    -------
    controls : LIST

    '''
    everything = cmds.ls(sl=True)
    controls = []
    if len(everything) != 0 :
        for item in everything:
            cmds.select(cl=True)
            newcircle = cmds.circle(r=rad,name=item+"_ctr")
            cmds.parent(newcircle,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newcircle[0])
    return  controls

####################################################################################################################################################################################################################################################################################################

def makeCtrLocators(*args):
    '''
    This scirpt creates a locator located a the selected transform or component.

    Usage Instructions
    ----------
    Select transform(s) or Vertex(s), run script.


    Parameters
    ----------
    NONE


    Raises
    ------
    TypeError : item does not have the required attributes to set location.

    Returns
    -------
    locators : LIST

    '''

    everything = cmds.ls(sl=True, fl=1)
    locators = []

    if len(everything) != 0:
        for item in everything:
            cmds.select(cl=True)
            try:
                newTrans = cmds.xform(item, q=1, ws=1, t=1)
                newRot = cmds.xform(item, q=1, ws=1, ro=1)
                locator = cmds.spaceLocator(name=item + "_loc")
                locators.append(locator[0])
                cmds.xform(locator, t=newTrans, ro=newRot)
                cmds.xform(locator, cp=True)
                cont2 = cmds.parentConstraint(item,locator)
                cmds.delete(cont2)

            except TypeError:
                newTrans = cmds.pointPosition(item, w=1)
                locator = cmds.spaceLocator(name=item + "_Point_loc", p=newTrans)
                locators.append(locator[0])
                cmds.xform(locator, cp=True)
            try:
                par = cmds.listRelatives(item, p=True)
                const = cmds.normalConstraint(par, locator)
                cmds.delete(const)
            except:
                print "nope"

    return locators


####################################################################################################################################################################################################################################################################################################

def SelectbuildIKFK(*args):
    '''
    This script build an IIK and FK systemn for selected joint chain.

    Usage Instructions
    ----------
    select toplevel join and run script.


    Parameters
    ----------
    NONE


    Returns
    NONE

    '''
    # make and bind joints
    bindJoints = cmds.ls(sl=True)
    ikJoints = []
    fkJoints = []
    print bindJoints
    bindchilds = cmds.listRelatives(bindJoints[0],ad=True)
    print bindchilds
    bindchilds.reverse()
    bindJoints = bindJoints + bindchilds
    print bindJoints
    cmds.select(cl=True)
    newikjoints = cmds.duplicate(bindJoints[0], rc=True)
    print newikjoints
    for ikjoint in newikjoints:
        renamedJoint = cmds.rename(ikjoint, "IK_" + ikjoint)
        ikJoints.append(renamedJoint)
    newFKjoints = cmds.duplicate(bindJoints[0], rc=True)
    print newFKjoints
    for fkjoint in newFKjoints:
        renamedJoint = cmds.rename(fkjoint, "FK_" + fkjoint)
        fkJoints.append(renamedJoint)

    print len(newFKjoints)
    ikfkParents = []
    cmds.select(cl=True)
    for things in range(0, (len(bindJoints))):
        ikfkParents = cmds.parentConstraint([ikJoints[things], fkJoints[things]], bindJoints[things])
        print ikfkParents
    print ikfkParents
    # create FK system
    cmds.select(cl=True)
    cmds.select(fkJoints[:-1])
    fklocators = makeCtrLocators()
    cmds.select(cl=True)
    cmds.select(fklocators)
    FKcontrols = circlethere()
    cmds.select(FKcontrols)
    cmds.xform(ro=[0, 90, 0])
    cmds.makeIdentity(a=True)
    ctrlsMade = len(fklocators)
    for item in range(0,ctrlsMade):
        if item !=0:
            cmds.parent(fklocators[item],FKcontrols[item-1])
    for item in FKcontrols:
        lockHide(item, [".tx", ".ty", ".tz", ".sx", ".sy", ".sz"])

    print fkJoints

    for cont in range(0, len(FKcontrols)):
        cmds.orientConstraint(FKcontrols[cont], fkJoints[cont])

    # build IK system
    print "building IK"
    ikHdl = cmds.ikHandle(sj=ikJoints[0], ee=ikJoints[-1], name=ikJoints[0][:-4] + "_ik_hdl")
    print ikHdl
    cmds.select(ikJoints[-1])
    ikloc = makeCtrLocators()
    IKcontrol = circlethere()
    cmds.xform(ro=[0, 90, 0])
    ikpointconstraint = cmds.pointConstraint(IKcontrol[0], ikHdl[0])
    lockHide(IKcontrol[0], [".rx", ".ry", ".rz", ".sx", ".sy", ".sz"])


####################################################################################################################################################################################################################################################################################################
def alignPvtTool(*args):
    '''
    This will center a transform between multiple objects.

    Usage Instructions
    ----------
    Select objects to center between, then select object to center, run script.


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    lastThing = cmds.ls(sl=True, tl=1)
    pContraint = cmds.pointConstraint()
    cmds.delete(pContraint)
    cmds.select(lastThing)


####################################################################################################################################################################################################################################################################################################

def parentShapeTool(*args):
    '''
    This script with parent the shape of an object to another transform. Useful for making controls with multiple shapes.

    Usage Instructions
    ----------
    Select transforms containing shapes you want to parent and then the target.


    Parameters
    ----------
    NONE


    Returns
    -------
    lastThing : LIST

    '''
    everything = cmds.ls(sl=True)
    lastThing = cmds.ls(sl=True, tl=1)
    if len(everything) >= 2:
        cmds.select(everything)
        cmds.select(lastThing, tgl=True)
        newthings = cmds.ls(sl=True)
        for thing in newthings:
            cmds.parent(thing, lastThing)
            cmds.makeIdentity(a=1, t=1, r=1, s=1)
            shapes = cmds.listRelatives(thing, s=True)
            for shape in shapes:
                cmds.parent(shape, lastThing, s=True, r=True)
            cmds.delete(thing)
        cmds.select(lastThing)
    return lastThing

####################################################################################################################################################################################################################################################################################################

def reorientJntTool(*args):
    '''
    This script moves the rotation vaules of a join to the orient values and zeros the rotations. Useful on end joints to make them align with the previous joint.

    Usage Instructions
    ----------
    Select joint(S) and run script.


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE


    '''
    everything = cmds.ls(sl=True, type="joint")
    for jnts in everything:
        currentRX = cmds.getAttr(jnts + ".rx")
        currentRY = cmds.getAttr(jnts + ".ry")
        currentRZ = cmds.getAttr(jnts + ".rz")
        currentOX = cmds.getAttr(jnts + ".jointOrientX")
        currentOY = cmds.getAttr(jnts + ".jointOrientY")
        currentOZ = cmds.getAttr(jnts + ".jointOrientZ")
        cmds.setAttr(jnts + ".jointOrientX", (currentRX))
        cmds.setAttr(jnts + ".jointOrientY", (currentRY))
        cmds.setAttr(jnts + ".jointOrientZ", (currentRZ))
        cmds.setAttr(jnts + ".rx", 0)
        cmds.setAttr(jnts + ".ry", 0)
        cmds.setAttr(jnts + ".rz", 0)


####################################################################################################################################################################################################################################################################################################

def mirrorThingX(*args):
    '''
    The script mirrors an object across the x axis

    Usage Instructions
    ----------
    select object, run script.


    Parameters
    ----------
    NONE

    Returns
    -------
    dup : OBJECT


    '''
    everything = cmds.ls(sl=True)
    if len(everything) != 0:
        for item in everything:
            dup = cmds.duplicate(rr=True)
            grp = cmds.group(w=True)
            cmds.xform(os=True, piv=(0, 0, 0))
            cmds.setAttr(grp + ".sx", -1)
            cmds.select(grp)
            cmds.ungroup()
            cmds.makeIdentity(a=1, t=1, r=1, s=1, n=0)
    return dup

####################################################################################################################################################################################################################################################################################################

def mirrorThingZ(*args):
    '''
    The script mirrors an object across the Z axis

    Usage Instructions
    ----------
    select object, run script.


    Parameters
    ----------
    NONE

    Returns
    -------
    dup : OBJECT


    '''

    everything = cmds.ls(sl=True)
    if len(everything) != 0:
        for item in everything:
            dup = cmds.duplicate(rr=True)
            grp = cmds.group(w=True)
            cmds.xform(os=True, piv=(0, 0, 0))
            cmds.setAttr(grp + ".sz", -1)
            cmds.select(grp)
            cmds.ungroup()
            cmds.makeIdentity(a=1, t=1, r=1, s=1, n=0)


####################################################################################################################################################################################################################################################################################################

def spiderJoint(*args):
    '''
    This script takes a transform or joint and creates 8 more joints a specificed distance at each of the carnal points and between them. Good for making joints to hold volumes.

    Usage Instructions
    ----------
    Select joint, run script.


    Parameters
    ---------
    NONE

    Returns
    -------
    newjoints: LIST

    '''
    distance = 5
    selectedjnts = cmds.ls(sl=True)
    if len(selectedjnts) != 0:
        for item in selectedjnts:
            cmds.select(cl=True)
            currentX = cmds.getAttr(item + ".tx")
            currentY = cmds.getAttr(item + ".ty")
            currentZ = cmds.getAttr(item + ".tz")
            startLoc = cmds.xform(item,q=True,ws=True,t=True)
            print currentX, currentY, currentZ
            print distance
            upjoint = cmds.joint(name=item + "_U_jnt",p=startLoc)
            cmds.select(cl=True)
            downjoint = cmds.joint(name=item + "_D_jnt",p=startLoc)
            cmds.select(cl=True)
            leftjoint = cmds.joint(name=item + "_L_jnt",p=startLoc)
            cmds.select(cl=True)
            rightjoint = cmds.joint(name=item + "_R_jnt",p=startLoc)
            cmds.select(cl=True)
            ULjoint = cmds.joint(name=item + "_UL_jnt",p=startLoc)
            cmds.select(cl=True)
            URjoint = cmds.joint(name=item + "_UR_jnt",p=startLoc)
            cmds.select(cl=True)
            DLjoint = cmds.joint(name=item + "_DL_jnt",p=startLoc)
            cmds.select(cl=True)
            DRjoint = cmds.joint(name=item + "_DR_jnt",p=startLoc)
            cmds.parent([upjoint, downjoint, leftjoint, rightjoint, ULjoint, URjoint, DLjoint, DRjoint], item)
            cmds.xform(upjoint,t=[0, distance, 0])
            print [0, distance, 0]
            cmds.xform(downjoint, t=[0, -distance, 0])
            cmds.xform(leftjoint, t=[0, 0, distance])
            cmds.xform(rightjoint, t=[0, 0, -distance])
            cmds.xform(URjoint, t=[0, distance, -distance])
            cmds.xform(DLjoint, t=[0, -distance, distance])
            cmds.xform(ULjoint, t=[0, distance, distance])
            cmds.xform(DRjoint, t=[0, -distance, -distance])
            newjoints = [upjoint, downjoint, leftjoint, rightjoint, URjoint, DLjoint, ULjoint, DRjoint]
            cmds.select()
            for jnts in newjoints:
                aimcon = cmds.aimConstraint(item,jnts,aim=[-1,0,0])
                cmds.delete(aimcon)
                currentRX = cmds.getAttr(jnts + ".rx")
                currentRY = cmds.getAttr(jnts + ".ry")
                currentRZ = cmds.getAttr(jnts + ".rz")
                currentOX = cmds.getAttr(jnts + ".jointOrientX")
                currentOY = cmds.getAttr(jnts + ".jointOrientY")
                currentOZ = cmds.getAttr(jnts + ".jointOrientZ")
                cmds.setAttr(jnts + ".jointOrientX", (currentRX))
                cmds.setAttr(jnts + ".jointOrientY", (currentRY))
                cmds.setAttr(jnts + ".jointOrientZ", (currentRZ))
                cmds.setAttr(jnts + ".rx", 0)
                cmds.setAttr(jnts + ".ry", 0)
                cmds.setAttr(jnts + ".rz", 0)
            cmds.select(cl=True)
            return newjoints


####################################################################################################################################################################################################################################################################################################

def createRigOrg(name = ""):
    '''
    This script makes a simple rigs hierarchy for keeping outliner organized while rigging.

    Usage Instructions
    ----------
    Run script createRigOrg(name= "")


    Parameters
    ----------
    name: STRING
    Rig Name



    Returns
    -------
    Rig_grp = LIST

    '''
    rigname = name
    Rig_grp = cmds.createNode("transform", name=rigname + "Rig_grp")
    worldNodes_grp = cmds.createNode("transform", name=rigname + "worldNodes_grp")
    ExtraNodes_grp = cmds.createNode("transform", name=rigname + "ExtraNodes_grp")
    Mesh_grp = cmds.createNode("transform", name=rigname + "Mesh_grp")
    cmds.parent([Mesh_grp,ExtraNodes_grp,worldNodes_grp],Rig_grp)
    Joints_grp = cmds.createNode("transform", name=rigname + "Joints_grp")
    Controls_grp = cmds.createNode("transform", name=rigname + "Controls_grp")
    cmds.parent([Joints_grp,Controls_grp],worldNodes_grp)
    return Rig_grp

def rigOrgPrompt(*args):
    '''
    Help UI script for rig oganization.

    Usage Instructions
    ----------
    Run script, enter name in prompt


    Parameters
    ----------
    NONE

    Returns
    -------
    NONE

    '''
    rigname = cmds.promptDialog(title='Rig Organization Name',message='Enter Name:',	button=['OK', 'Cancel'],defaultButton='OK',cancelButton='Cancel',dismissString='Cancel')
    if rigname == 'OK':
        setname = cmds.promptDialog(query=True, text=True)
        createRigOrg(setname)

####################################################################################################################################################################################################################################################################################################

def makeCircPointCtrl(*args):
    '''
    This script with make a circle and point constrain the selection to it.

    Usage Instructions
    ----------
    Seelct objects ton constrain, run script.



    Parameters
    ----------
    NONE


    Returns
    -------
    controls : LIST
    '''
    everything = cmds.ls(sl=True)
    locators = []
    if len(everything) != 0 :
        for item in everything:
            locator = cmds.spaceLocator(name=item+"_loc")
            constraint = cmds.parentConstraint(item,locator)
            cmds.delete(constraint)
            cmds.xform(a=True,ro=[0,0,0])
            locators.append(locator[0])
    if len(locators) != 0 :
        controls = []
        for item in locators:
            newcircle = cmds.circle(r=.5,name=item+"_ctr")
            cmds.parent(newcircle,item)
            cmds.xform(a=True,t=[0,0,0],ro=[0,0,0])
            controls.append(newcircle[0])
    for cont in range(0,len(everything)):
        cmds.pointConstraint(controls[cont],everything[cont])
    return controls


####################################################################################################################################################################################################################################################################################################
def spherethere(*args):
    '''
    DESCRIPTION

    Usage Instructions
    ----------



    Parameters
    ----------
    Parameter : Type


    Raises
    ------


    Returns
    -------

    '''
    everything = cmds.ls(sl=True)
    controls = []
    if len(everything) != 0:
        for item in everything:
            newcircle = cmds.sphere(r=.5, name=item + "_ctr")
            cmds.parent(newcircle, item)
            cmds.xform(a=True, t=[0, 0, 0], ro=[0, 0, 0])
            controls.append(newcircle[0])
    return controls


####################################################################################################################################################################################################################################################################################################

def spawnLocators(locLib,name="Default"):
    '''
    This script with create locators based on a ldictionary provided.

    Usage Instructions
    ----------
    Run script with dictionary and name.


    loclib = {
            "Limbtype" : "" ,
            "location":{"name":"locator Name","location":[X,Y,Z],"adult":"parent Target"},




    Parameters
    ----------
    locLib : DICTIONARY
    loclib = {
            "Limbtype" : "" ,
            "locationName":{"name":"locator Name","location":[X,Y,Z],"adult":"parent Target"}}
    name : STRING


    Returns
    -------
    newGroup : LIST

    '''
    locatorsStarts = locLib
    count = 0
    namePrefix = name + "_"
    while cmds.objExists(namePrefix + "grp"):
        count += 1
        namePrefix = name + str(count) + "_"
    builtLocs = []


    for key, value in locatorsStarts.items():
        print key, value
        if key == "LimbType" or key == "Limbtype":
            continue
        builtLocs.append(
            cmds.spaceLocator(n=namePrefix + value["name"] + "_loc", p=value["location"], a=True)[0])
        cmds.xform(cp=True)
    for key, value in locatorsStarts.items():
        if key == "LimbType" or key == "Limbtype":
            continue
        if value["adult"] != "":
            cmds.parent(namePrefix + value["name"] + "_loc", namePrefix + value["adult"] + "_loc")

    while cmds.objExists(namePrefix + "grp"):
        count += 1
        namePrefix = name + str(count) + "_"

    newGroup = cmds.group(builtLocs[0], name=namePrefix + "grp")
    cmds.addAttr(namePrefix + "grp", ln="LimbType", dt="string", k=True, h=False)
    cmds.setAttr(namePrefix + "grp.LimbType", locatorsStarts["Limbtype"], cb=True, type="string")
    return newGroup

####################################################################################################################################################################################################################################################################################################



def setupThreeJointLimb(*args):
    '''
    This is an example of how the spawnLocators function can be used.

    Usage Instructions
    ----------
    Run script


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE

    '''
    threeJointDict = {
            "Limbtype" : "threeJointLimb" ,
            "Start":{"name":"Start","location":[1,1,0],"adult":""},
            "Mid":{"name":"Mid","location":[5,2,0],"adult":"Start"},
            "End":{"name":"End","location":[10,1,0],"adult":"Mid"}}
    limbname = cmds.promptDialog(title='Limb Name',message='Enter Name:',	button=['OK', 'Cancel'],defaultButton='OK',cancelButton='Cancel',dismissString='Cancel')
    if limbname == 'OK':
        setname = cmds.promptDialog(query=True, text=True)
        Locations = spawnLocators(threeJointDict,name=setname)


####################################################################################################################################################################################################################################################################################################

def AIrenderCrvs(*args):
    '''
    This script makes all curves in scene Arnold rendered and creates shaders with the index color of the drawing overide set to the color.
    Usage Instructions
    ----------
    Run script on selection


    Parameters
    ----------
    NONE


    Returns
    -------
    NONE

    '''
    everything = cmds.ls(sl=True)
    print everything
    if len(everything) != 0 :
        for item in everything:
            shapes = cmds.listRelatives(item,s=True)
            for shape in shapes:
                if (cmds.objectType(shape) == "nurbsCurve"):
                    if cmds.getAttr(shape+".overrideColor") == 0:
                        print shape,"has a default index selected no shader made"
                        continue
                    else:
                        ShpCol = cmds.getAttr(shape+".overrideColor")
                        RGBshpCol = cmds.colorIndex(ShpCol,q=True )
                        print RGBshpCol
                        cmds.setAttr(shape+".aiRenderCurve",1)
                        createdShader = cmds.createNode('aiStandardSurface',name=shape+"_Sdr")
                        cmds.setAttr(createdShader+".aiEnableMatte",1)
                        cmds.setAttr(shape+".aiCurveWidth",0.03)
                        cmds.setAttr(createdShader+".aiMatteColor",RGBshpCol[0],RGBshpCol[1],RGBshpCol[2],type="double3" )
                        cmds.connectAttr(createdShader+".outColor",shape+".aiCurveShader",f=True)
                else:
                  print shape,"is not a nurbs Curve. Skipping."

####################################################################################################################################################################################################################################################################################################


def dontRenderCrvs(*args):
    everything = cmds.ls(typ="nurbsCurve")
    if len(everything) != 0 :
        for item in everything:
            cmds.setAttr(item+".aiRenderCurve",0)

####################################################################################################################################################################################################################################################################################################


def ShowoffMenu(*args):
    '''
    This is the Main Menu Function for easy access to all functions in File.

    Usage Instructions
    ----------
    Run Function to make Top level Menu for Library of Functions.



    Parameters
    ----------
    None

    Raises
    ------
    None

    Returns
    -------
    None

    '''
    if cmds.menu('CkExtraRiggingTools', exists=1):
        cmds.menu('CkExtraRiggingTools',e=True,dai=1,)
        cmds.deleteUI('CkExtraRiggingTools',m=True)
    showoffmenu = cmds.menu('CkExtraRiggingTools', p='MayaWindow', to=1, aob=1, l='Ck\'s Rigging Toolkit')
    print cmds.menu('CkExtraRiggingTools', exists=1)
    cmds.menuItem(p=showoffmenu, l="Contact Charles Kinter (Creator)", c=helpme)
    cmds.menuItem(p=showoffmenu, d=1)
    cmds.menuItem('generalTools',p=showoffmenu, l="General Rigging Tools",sm=1,to=1)
    cmds.menuItem(p='generalTools', l="Create rig Organization", c=rigOrgPrompt,ann="Creates Basic Rigging Organization")
    cmds.menuItem(p='generalTools', l="Turn off visable Local rotation Axis", c=fixLRA, ann="Turns off Display Local Rotation Axis on all objects in hierarchy.")
    cmds.menuItem(p='generalTools', l="Hide Visable Locators", c=fixLOC, ann="Disables all Visable Locators in the scene.")
    cmds.menuItem(p='generalTools', l="Unhide Locators", c=unfixLOC, ann="Shows all locators in the scene.")
    cmds.menuItem(p='generalTools', l="Spawn Rigging Controls", c=controls, ann="Launch shape creation tool for rigging control Shapes.")
    cmds.menuItem(p='generalTools', l="Change Shape Colors", c=clrUI, ann="Launch UI for changing shape colors to Red,Blue,Green,Yellow.")
    cmds.menuItem(p='generalTools', l="Add Keyable Color Override Channel to Shapes", c=pickShapeColor, ann="Create Color Overide Channel on Shape. To Use: Select Curve(s)")
    cmds.menuItem(p='generalTools', l="Center object Between two others", c=alignPvtTool, ann="To Use: Select Objects to center between, then select object to be centered.")
    cmds.menuItem(p='generalTools', l="Parent Shapes to last selected", c=parentShapeTool, ann="To Use: Select all shapes to be parented, then select transform to be parented under.")
    cmds.menuItem(p='generalTools', l="Mirror Objects Across X Axis", c=mirrorThingX, ann="To Use: Select object to mirror across X")
    cmds.menuItem(p='generalTools', l="Mirror Objects Across Z Axis", c=mirrorThingZ, ann="To Use: Select object to mirror across Z")
    cmds.menuItem(p='generalTools', l="Reorient EndJoint", c=reorientJntTool, ann="To Use:Select Joints with no orientation and rotation set to desired orientation.")
    cmds.menuItem(p='generalTools', l="Make control curves arnold renderable", c=AIrenderCrvs, ann="To Use:Select curves you want renderable.")
    cmds.menuItem(p='generalTools', l="Turns off arnold rendering of all curves in the scene", c=dontRenderCrvs, ann="Turns off arnold rendering of all curves in the scene")
    cmds.menuItem(p='generalTools', l="Create Shader From Folder of textures", c=iscWindow, ann="Creates a specified shader from files in folder selected.")
    cmds.menuItem('processTools',p=showoffmenu, l="Process Speedup Rigging Tools",sm=1,to=1)
    cmds.menuItem(p='processTools', l="Create Locator at selection", c=makeCtrLocators, ann="To Use:Select Verticies or Objects to create locators at pivots.")
    cmds.menuItem(p='processTools', l="Build Bind Joints from Locators", c=buildBindJointsFromLocs, ann="To Use: Select Heirachy of transforms or locators")
    cmds.menuItem(p='processTools', l="Build IK/FK Controls from Joint chain", c=SelectbuildIKFK, ann="Builds basic IK/FK setup ready to link to switch. To use: Select top joint in heirarcy you wish to duplicate.")
    cmds.menuItem(p='processTools', l="Make Joint Chains from selected to Center", c=makeEyeJoint, ann="To Use: Select locators for end joints then select center point transform.")
    cmds.menuItem(p='processTools', l="Make Aim Locators from EndJoint", c=makeAims, ann="To Use: Select End joints, aim will be setup from immediate parent to the locator created at those joints.")
    cmds.menuItem(p='processTools', l="Make EP Curve From Selected transforms", c=makeCurveFromSel, ann="To Use: Select transforms in order of points you want on the curve.")
    cmds.menuItem(p='processTools', l="Pin transforms to Curve", c=pinToCrv, ann="To Use: Select transforms along curve then select the curve.")
    cmds.menuItem(p='processTools', l="Put Joints at EPs of Curve", c=curveEPsToJnts, ann="To Use: Select Curve to create joints along.")
    cmds.menuItem(p='processTools', l="Make Clusters and Controls at CVs", c=curveCVsToCtrls, ann="To Use: Select Curve to create clusters on.")
    cmds.menuItem(p='processTools', l="Make Cluster Control from Verts", c=makeclstrPointCtrlprompt, ann="To Use: Select verticies to expand from and make clusters on. ")
    cmds.menuItem(p='processTools', l="Make Joint Control from Verts", c=makeVertJointCtrl, ann="To Use: Select vertices to place joints at.")
    cmds.menuItem(p='processTools', l="Make Sphere Control from selection", c=makePointCtrl, ann="To Use: Select object to make a point constrained control Sphere.")
    cmds.menuItem(p='processTools', l="Make Circle Control from selection", c=makeCircPointCtrl, ann="To Use: Select object to make a point constrained control nurbs circle.")
    cmds.menuItem(p='processTools', l="Create 8 Way Child joints around center", c=spiderJoint, ann="To Use: Select joint/object to be Origin.")
    cmds.menuItem(p='processTools', l="Create Ribbon Tool", c=ribbonUI, ann="This launches the ui for creating ribbons.")
    cmds.menuItem(p=showoffmenu, d=1)
    cmds.menuItem(p=showoffmenu, l='Last Updated 12/20/13')
    cmds.menuItem(p=showoffmenu, l='Version 1.1')




def controls(*args):
    contui = rigCntsUI()
    contui.createWin()


# Help Function
def helpme(*args):
    cmds.launch(web="http://charles.kinters.net/sample-page/contact-me/")



####################################################################################################################################################################################################################################################################################################
# Testing Area


if __name__ == "__main__":
    ShowoffMenu()
    print "worked"

